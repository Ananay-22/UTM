<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>UTM.map API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/atom-one-dark.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>UTM.map</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># forward declare types
from __future__ import annotations

from enum import Enum
from itertools import combinations
from agents import Agent, DroneAgent, ForwardDroneAgent
from comms import CommunicationFabric

from constants import BLUE, GRAY, GREEN, PURPLE, RED, WHITE, Dimension2D, DroneSimContext, Orientation2D
from computed import alphaFromZ
from dispatcher import DispatchVertiport, ReceiveVertiport
from drone import Action2D, DroneState, DroneStateContext, MemoryContext

from render_util import drawAlphaCoordBlock, drawArrow, drawCoordBlock
from utils import has

class Channel2D:
    &#34;&#34;&#34;
    Class representing an individual channel in a 2D map.
    A channel is a line of air cells.
    The channels currently are unidirectional.
    Multiple channels make an aircorridor.
    &#34;&#34;&#34;
    def __init__(self, idx: int, dir: Action2D, orientation: Orientation2D):
        self.idx: int = idx
        &#34;&#34;&#34;
        The index of the channel in the corridor.
        &#34;&#34;&#34;
        self.dir: Action2D = dir
        &#34;&#34;&#34;
        The direction of the channel. Determines which directions the drones can move.
        &#34;&#34;&#34;
        self.orientation: Orientation2D = orientation
        &#34;&#34;&#34;
        The orientation of the channel on the map. Vertical or Horizontal.
        &#34;&#34;&#34;
    
    def getDirection(self) -&gt; Action2D:
        &#34;&#34;&#34;
        Returns the direction of the channel. Drones must flow along this direction unless in intersections.
        &#34;&#34;&#34;
        __map = {
            Orientation2D.HORIZONTAL: {
                &#34;0&#34;: Action2D.WEST,
                &#34;1&#34;: Action2D.EAST
            },
            Orientation2D.VERTICAL: {
                &#34;0&#34;: Action2D.NORTH,
                &#34;1&#34;: Action2D.SOUTH
            }
        }
        return __map[self.orientation][self.dir]

class Corridor2D:
    &#34;&#34;&#34;
    A class representing a Corridor in a 2D Map.
    Contains multiple channels. Drones can only be in one channel at a time unless in an intersection.
    &#34;&#34;&#34;
    def __init__(self, orientation: Orientation2D, x: int, y: int, length: int, width: int, dir: Action2D):
        &#34;&#34;&#34;
        If a Corridor is added into a map file as:
            CORRIDOR H 0 9 20 2 1

        Corridor direction is Horizontal.
        Corridor start coordinate is (0, 9).
        Corridor length is 20.
        Corridor has 2 channels.
        The direction value is 1.

        Since there are 2 corridors, we will convert this into a 2 digit binary number: 01
        Since this is a horizontal corridor, channels can only have EAST or WEST directions.

        Channel at index 0 will have direction associated with 0 () and channel at index 1 will have direction associated with 1 ().
        &#34;&#34;&#34;
        self.orientation: Orientation2D = orientation
        &#34;&#34;&#34;
        Represents the orientation of the corridor.
        &#34;&#34;&#34;
        self.x: int = x
        &#34;&#34;&#34;
        The x coordinate of the top left point of the corridor.
        &#34;&#34;&#34;
        self.y: int = y
        &#34;&#34;&#34;
        The y coordinate of the top left point of the corridor.
        &#34;&#34;&#34;
        self.length: int = length
        &#34;&#34;&#34;
        The length of the corridor.
        &#34;&#34;&#34;
        self.width: int = width
        &#34;&#34;&#34;
        The width of the corridor.
        &#34;&#34;&#34;
        dir_parsed = f&#39;{dir:0{width}b}&#39;
        self.channels: list[Channel2D] = [Channel2D(i, dir_parsed[i], self.orientation) for i in range(width)]
        &#34;&#34;&#34;
        A list of all the channels in the corridor.
        &#34;&#34;&#34;

    def getRectangle(self) -&gt; tuple[int, int, int, int]:
        &#34;&#34;&#34;
        returns the rectangle containing the entire corridor.
        &#34;&#34;&#34;
        return (self.x, self.y, self.length if self.orientation == Orientation2D.HORIZONTAL else self.width, self.width if self.orientation == Orientation2D.HORIZONTAL else self.length)

    def intersects(self, other: Corridor2D) -&gt; bool:
        &#34;&#34;&#34;
        checks if 2 corridors intersect.
        &#34;&#34;&#34;
        rect1 = self.getRectangle()
        rect2 = other.getRectangle()
        return not (
            rect1[0] &gt; rect2[3] or rect2[0] &gt; rect1[3]
            or
            rect1[2] &gt; rect2[4] or rect2[2] &gt; rect1[4]
        )
    
    def getIntersectionBounds(self, other: Corridor2D) -&gt; tuple(int, int, int, int):
        &#34;&#34;&#34;
        returns the rectangle representing the intersection of 2 corridors.
        &#34;&#34;&#34;
        if not self.intersects(other):
            rect1 = self.getRectangle()
            rect2 = other.getRectangle()
            left = max(rect1[0], rect2[0])
            top = max(rect1[1], rect2[1])
            right = min(rect1[0] + rect1[2], rect2[0] + rect2[2])
            bottom = min(rect1[1] + rect1[3], rect2[1] + rect2[3])
            return (left, top, right - left, bottom - top)

    def render(self, zIdx: int):
        &#34;&#34;&#34;
        Draws the corridor onto the screen.
        &#34;&#34;&#34;
        for l_offset in range(self.length):
            for channel in self.channels:
                if self.orientation == Orientation2D.HORIZONTAL:
                    drawAlphaCoordBlock(
                        self.x + l_offset,
                        self.y + channel.idx,
                        color=(*(
                            RED if channel.idx else GREEN
                        ), alphaFromZ(zIdx))
                    )
                elif self.orientation == Orientation2D.VERTICAL:
                    drawAlphaCoordBlock(
                        self.x + channel.idx,
                        self.y + l_offset,
                        color=(*(
                            PURPLE if channel.idx else BLUE
                        ), alphaFromZ(zIdx))
                    )
    def has(self, x: int, y: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks that the given coordinates are inside the corridor.
        &#34;&#34;&#34;
        return has(x, y, *self.getRectangle())

    def get_containing_channel(self, x: int, y: int) -&gt; Channel2D:
        &#34;&#34;&#34;
        returns the channel containing the given coordinate.
        &#34;&#34;&#34;
        if self.has(x, y):
            if self.orientation == Orientation2D.HORIZONTAL:
                return self.channels[y - self.y]
            elif self.orientation == Orientation2D.VERTICAL:
                return self.channels[x - self.x]


class Intersection:
    &#34;&#34;&#34;
    A class representing an intersection in 2D.
    &#34;&#34;&#34;
    def __init__(self, corridor1: Corridor2D, corridor2: Corridor2D, intersectionRect: tuple[int, int. int. int]):
        [self.x, self.y, self.length, self.breadth] = intersectionRect
        &#34;&#34;&#34;
        x: the x coordinate of the top left point of the intersection.
        y: the y coordinate of the top left point of the intersection.
        length: the length of the intersection.
        breadth: the breadth of the intersection.
        &#34;&#34;&#34;
        self.corridor1: Corridor2D = corridor1
        &#34;&#34;&#34;
        The first corridor this intersection is a part of.
        &#34;&#34;&#34;
        self.corridor2: Corridor2D = corridor2
        &#34;&#34;&#34;
        The second corridor this intersection is a part of.
        &#34;&#34;&#34;

    def has(self, x: int, y: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if an intersection contains the given x, y coordinates.
        &#34;&#34;&#34;
        return has(x, y, self.x, self.y, self.length, self.breadth)

    def render(self, zIdx: int):
        &#34;&#34;&#34;
        Draws the intersection on the map.
        &#34;&#34;&#34;
        for x in range(self.x, self.x + self.length):
            for y in range(self.y, self.y + self.breadth):
                drawAlphaCoordBlock(x, y, color=(*GRAY, alphaFromZ(zIdx)))

class Map2D:
    &#34;&#34;&#34;
    A class representing a 2D Map.
    TODO: 2 ways of keeping track of a map: sparse and aircell. Currently Sparse implemented.
    &#34;&#34;&#34;
    def __init__(self):
        self.corridors: list[Corridor2D] = []
        &#34;&#34;&#34;
        A list of all corridors in this map.
        &#34;&#34;&#34;
        self.dimension: Dimension2D = Dimension2D(0, 0)
        &#34;&#34;&#34;
        The Dimensions of this map.
        &#34;&#34;&#34;
        self.intersections: list[Intersection] = []
        &#34;&#34;&#34;
        A list of all the intersections of the map.
        &#34;&#34;&#34;
        self.drones_states: list[DroneState] = []
        &#34;&#34;&#34;
        A list of all the drone states present on the map.
        &#34;&#34;&#34;
        self.agent: Agent = ForwardDroneAgent()
        &#34;&#34;&#34;
        The agent controlling the drone states on the map.
        &#34;&#34;&#34;
        self.dispatchers: list[DispatchVertiport] = []
        &#34;&#34;&#34;
        A list of all the dispatcher vertiports in the map.
        &#34;&#34;&#34;
        self.goals: dict[ReceiveVertiport, list[DroneState]] = dict()
        &#34;&#34;&#34;
        A dictionary mapping all receiving vertiports to all drones that have that vertiport&#39;s coordinates as a goal.
        &#34;&#34;&#34;
        self.comms: CommunicationFabric = CommunicationFabric()
        &#34;&#34;&#34;
        The communication fabric on this map.
        &#34;&#34;&#34;
        self.mems: dict[str, MemoryContext] = dict()
        &#34;&#34;&#34;
        The memory of all drones on this map.
        TODO: encapsulate in drone state
        &#34;&#34;&#34;

    def has(self, x: int, y: int) -&gt; bool:
        &#34;&#34;&#34;
        checks if this given x, y coordinate is in the map bounds.
        &#34;&#34;&#34;
        return has(x,y, 0, 0, self.dimension.width, self.dimension.height)
        
    def get_containing_corridor(self, x: int, y: int) -&gt; Corridor2D:
        &#34;&#34;&#34;
        given an x, y coordinate, returns the corridor that would contain this coordinate or else returns None.
        &#34;&#34;&#34;
        for corridor in self.corridors:
            if corridor.has(x, y):
                return corridor

    def get_containing_intersection(self, x: int, y: int) -&gt; Intersection2D:
        &#34;&#34;&#34;
        given an x, y coordinate, returns the intersection that would contain this coordinate or else returns None.
        &#34;&#34;&#34;
        for intersection in self.intersections:
            if intersection.has(x, y):
                return intersection

    def update_intersections(self):
        &#34;&#34;&#34;
        Called to compute all the intersections on the map given the corridors on this map.
        &#34;&#34;&#34;
        self.intersections = []
        for (a, b) in combinations(self.corridors, 2):
            intersectionBounds = a.getIntersectionBounds(b)
            if intersectionBounds:
                self.intersections += [Intersection(a, b, intersectionBounds)]
    
    def to_arr(self) -&gt; list[list[str]]:
        &#34;&#34;&#34;
        Converts the map to an array representation.
        TODO: describe representation.
        &#34;&#34;&#34;
        map_base = [[&#34;O&#34; for _ in range(self.dimension.width)] for _ in range(self.dimension.height)]
        for corridor in self.corridors:
            if corridor.orientation == Orientation2D.HORIZONTAL:
                for channel in corridor.channels:
                    for i in range(corridor.length):
                        map_base[corridor.y + channel.idx][i + corridor.x] += &#34;&lt;&#34; if channel.dir == &#34;0&#34; else &#34;&gt;&#34;
            elif corridor.orientation == Orientation2D.VERTICAL:
                for channel in corridor.channels:
                    for i in range(corridor.length):
                        map_base[i + corridor.y][corridor.x + channel.idx] += &#34;v&#34; if channel.dir == &#34;1&#34; else &#34;^&#34;
        for intersection in self.intersections:
            for i in range(intersection.length):
                for j in range(intersection.breadth):
                    map_base[intersection.y + j][intersection.x + i] += &#34;@&#34;
        
        return map_base

    def render(self, zIdx: int):
        &#34;&#34;&#34;
        Draws the map onto the screen.
        &#34;&#34;&#34;
        for x in range(self.dimension.width):
            for y in range(self.dimension.height):
                drawAlphaCoordBlock(x, y)

        for corridor in self.corridors:
            corridor.render(zIdx + 1)
        
        for intersection in self.intersections:
            intersection.render(zIdx + 1)

        for drone in self.drones_states:
            drone.render(zIdx + 1)

        for dispatcher in self.dispatchers:
            dispatcher.render(zIdx + 1)

        for x in range(self.dimension.width):
            for y in range(self.dimension.height):
                drawCoordBlock(x, y, color=(*WHITE, alphaFromZ(zIdx)), border=1)
                corridor = self.get_containing_corridor(x, y)
                if corridor:
                    channel = corridor.get_containing_channel(x, y)
                    if channel and not self.get_containing_intersection(x, y):
                        drawArrow(x, y, channel.getDirection())


    def update(self):
        &#34;&#34;&#34;
        Updates all the components on the map.
        &#34;&#34;&#34;
        for drone_state in self.drones_states:
            if  drone_state.goal in self.goals and drone_state.goal.has(drone_state.getCoords().x, drone_state.getCoords().y):
                drone_state.goal.receive(drone_state)
                self.goals[drone_state.goal] = list(filter(lambda e: e != drone_state, self.goals[drone_state.goal]))
                self.drones_states = list(filter(lambda e: e != drone_state, self.drones_states))
                continue
            if drone_state.id not in self.mems:
                self.mems[drone_state.id] = MemoryContext()
            drone_state.applyAction(self.agent.getAction(DroneStateContext(drone_state, self.mems[drone_state.id]), DroneSimContext(drone_state, self)))
            # TODO: have drone push message onto fabric
        
        for dispatcher in self.dispatchers:
            dispatched_drone = dispatcher.dispatch()
            if dispatched_drone:
                self.drones_states += [dispatched_drone]
            dispatcher.update()
        
        self.comms.update()

    def set_global_agent(self, agent: DroneAgent):
        &#34;&#34;&#34;
        Changes the Agents controlling each drone on the simulation.
        &#34;&#34;&#34;
        if isinstance(agent, DroneAgent):
            self.agent = agent
        elif issubclass(agent, DroneAgent):
            self.agent = agent()
    
    def apply_simulation_settings(self, settings):
        &#34;&#34;&#34;
        Applies the given settings onto the simulation.
        TODO: describe the settings dict.
        &#34;&#34;&#34;
        _SIMULATION_SETTINGS_LOOKUP = {
            &#34;global-agent&#34;: lambda e: self.set_global_agent(e)
        }

        for key in settings:
            if key in _SIMULATION_SETTINGS_LOOKUP:
                _SIMULATION_SETTINGS_LOOKUP[key](settings[key])

    def shutdown(self, drone: DroneState):
        &#34;&#34;&#34;
        Shuts down the drone and removes it from the map (if not called here it will still be on the map and will be an error). Furthermore there might be a mem leak.
        &#34;&#34;&#34;
        if drone in self.drones_states:
            drone.shutdown()
            if drone.id in self.mems:
                del self.mems[drone.id]
            self.drones_states.remove(drone)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="UTM.map.Channel2D"><code class="flex name class">
<span>class <span class="ident">Channel2D</span></span>
<span>(</span><span>idx: int, dir: Action2D, orientation: Orientation2D)</span>
</code></dt>
<dd>
<div class="desc"><p>Class representing an individual channel in a 2D map.
A channel is a line of air cells.
The channels currently are unidirectional.
Multiple channels make an aircorridor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Channel2D:
    &#34;&#34;&#34;
    Class representing an individual channel in a 2D map.
    A channel is a line of air cells.
    The channels currently are unidirectional.
    Multiple channels make an aircorridor.
    &#34;&#34;&#34;
    def __init__(self, idx: int, dir: Action2D, orientation: Orientation2D):
        self.idx: int = idx
        &#34;&#34;&#34;
        The index of the channel in the corridor.
        &#34;&#34;&#34;
        self.dir: Action2D = dir
        &#34;&#34;&#34;
        The direction of the channel. Determines which directions the drones can move.
        &#34;&#34;&#34;
        self.orientation: Orientation2D = orientation
        &#34;&#34;&#34;
        The orientation of the channel on the map. Vertical or Horizontal.
        &#34;&#34;&#34;
    
    def getDirection(self) -&gt; Action2D:
        &#34;&#34;&#34;
        Returns the direction of the channel. Drones must flow along this direction unless in intersections.
        &#34;&#34;&#34;
        __map = {
            Orientation2D.HORIZONTAL: {
                &#34;0&#34;: Action2D.WEST,
                &#34;1&#34;: Action2D.EAST
            },
            Orientation2D.VERTICAL: {
                &#34;0&#34;: Action2D.NORTH,
                &#34;1&#34;: Action2D.SOUTH
            }
        }
        return __map[self.orientation][self.dir]</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="UTM.map.Channel2D.dir"><code class="name">var <span class="ident">dir</span></code></dt>
<dd>
<div class="desc"><p>The direction of the channel. Determines which directions the drones can move.</p></div>
</dd>
<dt id="UTM.map.Channel2D.idx"><code class="name">var <span class="ident">idx</span></code></dt>
<dd>
<div class="desc"><p>The index of the channel in the corridor.</p></div>
</dd>
<dt id="UTM.map.Channel2D.orientation"><code class="name">var <span class="ident">orientation</span></code></dt>
<dd>
<div class="desc"><p>The orientation of the channel on the map. Vertical or Horizontal.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="UTM.map.Channel2D.getDirection"><code class="name flex">
<span>def <span class="ident">getDirection</span></span>(<span>self) ‑> constants.Action2D</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the direction of the channel. Drones must flow along this direction unless in intersections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDirection(self) -&gt; Action2D:
    &#34;&#34;&#34;
    Returns the direction of the channel. Drones must flow along this direction unless in intersections.
    &#34;&#34;&#34;
    __map = {
        Orientation2D.HORIZONTAL: {
            &#34;0&#34;: Action2D.WEST,
            &#34;1&#34;: Action2D.EAST
        },
        Orientation2D.VERTICAL: {
            &#34;0&#34;: Action2D.NORTH,
            &#34;1&#34;: Action2D.SOUTH
        }
    }
    return __map[self.orientation][self.dir]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="UTM.map.Corridor2D"><code class="flex name class">
<span>class <span class="ident">Corridor2D</span></span>
<span>(</span><span>orientation: Orientation2D, x: int, y: int, length: int, width: int, dir: Action2D)</span>
</code></dt>
<dd>
<div class="desc"><p>A class representing a Corridor in a 2D Map.
Contains multiple channels. Drones can only be in one channel at a time unless in an intersection.</p>
<p>If a Corridor is added into a map file as:
CORRIDOR H 0 9 20 2 1</p>
<p>Corridor direction is Horizontal.
Corridor start coordinate is (0, 9).
Corridor length is 20.
Corridor has 2 channels.
The direction value is 1.</p>
<p>Since there are 2 corridors, we will convert this into a 2 digit binary number: 01
Since this is a horizontal corridor, channels can only have EAST or WEST directions.</p>
<p>Channel at index 0 will have direction associated with 0 () and channel at index 1 will have direction associated with 1 ().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Corridor2D:
    &#34;&#34;&#34;
    A class representing a Corridor in a 2D Map.
    Contains multiple channels. Drones can only be in one channel at a time unless in an intersection.
    &#34;&#34;&#34;
    def __init__(self, orientation: Orientation2D, x: int, y: int, length: int, width: int, dir: Action2D):
        &#34;&#34;&#34;
        If a Corridor is added into a map file as:
            CORRIDOR H 0 9 20 2 1

        Corridor direction is Horizontal.
        Corridor start coordinate is (0, 9).
        Corridor length is 20.
        Corridor has 2 channels.
        The direction value is 1.

        Since there are 2 corridors, we will convert this into a 2 digit binary number: 01
        Since this is a horizontal corridor, channels can only have EAST or WEST directions.

        Channel at index 0 will have direction associated with 0 () and channel at index 1 will have direction associated with 1 ().
        &#34;&#34;&#34;
        self.orientation: Orientation2D = orientation
        &#34;&#34;&#34;
        Represents the orientation of the corridor.
        &#34;&#34;&#34;
        self.x: int = x
        &#34;&#34;&#34;
        The x coordinate of the top left point of the corridor.
        &#34;&#34;&#34;
        self.y: int = y
        &#34;&#34;&#34;
        The y coordinate of the top left point of the corridor.
        &#34;&#34;&#34;
        self.length: int = length
        &#34;&#34;&#34;
        The length of the corridor.
        &#34;&#34;&#34;
        self.width: int = width
        &#34;&#34;&#34;
        The width of the corridor.
        &#34;&#34;&#34;
        dir_parsed = f&#39;{dir:0{width}b}&#39;
        self.channels: list[Channel2D] = [Channel2D(i, dir_parsed[i], self.orientation) for i in range(width)]
        &#34;&#34;&#34;
        A list of all the channels in the corridor.
        &#34;&#34;&#34;

    def getRectangle(self) -&gt; tuple[int, int, int, int]:
        &#34;&#34;&#34;
        returns the rectangle containing the entire corridor.
        &#34;&#34;&#34;
        return (self.x, self.y, self.length if self.orientation == Orientation2D.HORIZONTAL else self.width, self.width if self.orientation == Orientation2D.HORIZONTAL else self.length)

    def intersects(self, other: Corridor2D) -&gt; bool:
        &#34;&#34;&#34;
        checks if 2 corridors intersect.
        &#34;&#34;&#34;
        rect1 = self.getRectangle()
        rect2 = other.getRectangle()
        return not (
            rect1[0] &gt; rect2[3] or rect2[0] &gt; rect1[3]
            or
            rect1[2] &gt; rect2[4] or rect2[2] &gt; rect1[4]
        )
    
    def getIntersectionBounds(self, other: Corridor2D) -&gt; tuple(int, int, int, int):
        &#34;&#34;&#34;
        returns the rectangle representing the intersection of 2 corridors.
        &#34;&#34;&#34;
        if not self.intersects(other):
            rect1 = self.getRectangle()
            rect2 = other.getRectangle()
            left = max(rect1[0], rect2[0])
            top = max(rect1[1], rect2[1])
            right = min(rect1[0] + rect1[2], rect2[0] + rect2[2])
            bottom = min(rect1[1] + rect1[3], rect2[1] + rect2[3])
            return (left, top, right - left, bottom - top)

    def render(self, zIdx: int):
        &#34;&#34;&#34;
        Draws the corridor onto the screen.
        &#34;&#34;&#34;
        for l_offset in range(self.length):
            for channel in self.channels:
                if self.orientation == Orientation2D.HORIZONTAL:
                    drawAlphaCoordBlock(
                        self.x + l_offset,
                        self.y + channel.idx,
                        color=(*(
                            RED if channel.idx else GREEN
                        ), alphaFromZ(zIdx))
                    )
                elif self.orientation == Orientation2D.VERTICAL:
                    drawAlphaCoordBlock(
                        self.x + channel.idx,
                        self.y + l_offset,
                        color=(*(
                            PURPLE if channel.idx else BLUE
                        ), alphaFromZ(zIdx))
                    )
    def has(self, x: int, y: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks that the given coordinates are inside the corridor.
        &#34;&#34;&#34;
        return has(x, y, *self.getRectangle())

    def get_containing_channel(self, x: int, y: int) -&gt; Channel2D:
        &#34;&#34;&#34;
        returns the channel containing the given coordinate.
        &#34;&#34;&#34;
        if self.has(x, y):
            if self.orientation == Orientation2D.HORIZONTAL:
                return self.channels[y - self.y]
            elif self.orientation == Orientation2D.VERTICAL:
                return self.channels[x - self.x]</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="UTM.map.Corridor2D.channels"><code class="name">var <span class="ident">channels</span></code></dt>
<dd>
<div class="desc"><p>A list of all the channels in the corridor.</p></div>
</dd>
<dt id="UTM.map.Corridor2D.length"><code class="name">var <span class="ident">length</span></code></dt>
<dd>
<div class="desc"><p>The length of the corridor.</p></div>
</dd>
<dt id="UTM.map.Corridor2D.orientation"><code class="name">var <span class="ident">orientation</span></code></dt>
<dd>
<div class="desc"><p>Represents the orientation of the corridor.</p></div>
</dd>
<dt id="UTM.map.Corridor2D.width"><code class="name">var <span class="ident">width</span></code></dt>
<dd>
<div class="desc"><p>The width of the corridor.</p></div>
</dd>
<dt id="UTM.map.Corridor2D.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<div class="desc"><p>The x coordinate of the top left point of the corridor.</p></div>
</dd>
<dt id="UTM.map.Corridor2D.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<div class="desc"><p>The y coordinate of the top left point of the corridor.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="UTM.map.Corridor2D.getIntersectionBounds"><code class="name flex">
<span>def <span class="ident">getIntersectionBounds</span></span>(<span>self, other: <a title="UTM.map.Corridor2D" href="#UTM.map.Corridor2D">Corridor2D</a>) ‑> tuple(int, int, int, int)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the rectangle representing the intersection of 2 corridors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getIntersectionBounds(self, other: Corridor2D) -&gt; tuple(int, int, int, int):
    &#34;&#34;&#34;
    returns the rectangle representing the intersection of 2 corridors.
    &#34;&#34;&#34;
    if not self.intersects(other):
        rect1 = self.getRectangle()
        rect2 = other.getRectangle()
        left = max(rect1[0], rect2[0])
        top = max(rect1[1], rect2[1])
        right = min(rect1[0] + rect1[2], rect2[0] + rect2[2])
        bottom = min(rect1[1] + rect1[3], rect2[1] + rect2[3])
        return (left, top, right - left, bottom - top)</code></pre>
</details>
</dd>
<dt id="UTM.map.Corridor2D.getRectangle"><code class="name flex">
<span>def <span class="ident">getRectangle</span></span>(<span>self) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>returns the rectangle containing the entire corridor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getRectangle(self) -&gt; tuple[int, int, int, int]:
    &#34;&#34;&#34;
    returns the rectangle containing the entire corridor.
    &#34;&#34;&#34;
    return (self.x, self.y, self.length if self.orientation == Orientation2D.HORIZONTAL else self.width, self.width if self.orientation == Orientation2D.HORIZONTAL else self.length)</code></pre>
</details>
</dd>
<dt id="UTM.map.Corridor2D.get_containing_channel"><code class="name flex">
<span>def <span class="ident">get_containing_channel</span></span>(<span>self, x: int, y: int) ‑> <a title="UTM.map.Channel2D" href="#UTM.map.Channel2D">Channel2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>returns the channel containing the given coordinate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_containing_channel(self, x: int, y: int) -&gt; Channel2D:
    &#34;&#34;&#34;
    returns the channel containing the given coordinate.
    &#34;&#34;&#34;
    if self.has(x, y):
        if self.orientation == Orientation2D.HORIZONTAL:
            return self.channels[y - self.y]
        elif self.orientation == Orientation2D.VERTICAL:
            return self.channels[x - self.x]</code></pre>
</details>
</dd>
<dt id="UTM.map.Corridor2D.has"><code class="name flex">
<span>def <span class="ident">has</span></span>(<span>self, x: int, y: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that the given coordinates are inside the corridor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has(self, x: int, y: int) -&gt; bool:
    &#34;&#34;&#34;
    Checks that the given coordinates are inside the corridor.
    &#34;&#34;&#34;
    return has(x, y, *self.getRectangle())</code></pre>
</details>
</dd>
<dt id="UTM.map.Corridor2D.intersects"><code class="name flex">
<span>def <span class="ident">intersects</span></span>(<span>self, other: <a title="UTM.map.Corridor2D" href="#UTM.map.Corridor2D">Corridor2D</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>checks if 2 corridors intersect.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersects(self, other: Corridor2D) -&gt; bool:
    &#34;&#34;&#34;
    checks if 2 corridors intersect.
    &#34;&#34;&#34;
    rect1 = self.getRectangle()
    rect2 = other.getRectangle()
    return not (
        rect1[0] &gt; rect2[3] or rect2[0] &gt; rect1[3]
        or
        rect1[2] &gt; rect2[4] or rect2[2] &gt; rect1[4]
    )</code></pre>
</details>
</dd>
<dt id="UTM.map.Corridor2D.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, zIdx: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the corridor onto the screen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, zIdx: int):
    &#34;&#34;&#34;
    Draws the corridor onto the screen.
    &#34;&#34;&#34;
    for l_offset in range(self.length):
        for channel in self.channels:
            if self.orientation == Orientation2D.HORIZONTAL:
                drawAlphaCoordBlock(
                    self.x + l_offset,
                    self.y + channel.idx,
                    color=(*(
                        RED if channel.idx else GREEN
                    ), alphaFromZ(zIdx))
                )
            elif self.orientation == Orientation2D.VERTICAL:
                drawAlphaCoordBlock(
                    self.x + channel.idx,
                    self.y + l_offset,
                    color=(*(
                        PURPLE if channel.idx else BLUE
                    ), alphaFromZ(zIdx))
                )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="UTM.map.Intersection"><code class="flex name class">
<span>class <span class="ident">Intersection</span></span>
<span>(</span><span>corridor1: <a title="UTM.map.Corridor2D" href="#UTM.map.Corridor2D">Corridor2D</a>, corridor2: <a title="UTM.map.Corridor2D" href="#UTM.map.Corridor2D">Corridor2D</a>, intersectionRect: tuple[int, int.int.int])</span>
</code></dt>
<dd>
<div class="desc"><p>A class representing an intersection in 2D.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Intersection:
    &#34;&#34;&#34;
    A class representing an intersection in 2D.
    &#34;&#34;&#34;
    def __init__(self, corridor1: Corridor2D, corridor2: Corridor2D, intersectionRect: tuple[int, int. int. int]):
        [self.x, self.y, self.length, self.breadth] = intersectionRect
        &#34;&#34;&#34;
        x: the x coordinate of the top left point of the intersection.
        y: the y coordinate of the top left point of the intersection.
        length: the length of the intersection.
        breadth: the breadth of the intersection.
        &#34;&#34;&#34;
        self.corridor1: Corridor2D = corridor1
        &#34;&#34;&#34;
        The first corridor this intersection is a part of.
        &#34;&#34;&#34;
        self.corridor2: Corridor2D = corridor2
        &#34;&#34;&#34;
        The second corridor this intersection is a part of.
        &#34;&#34;&#34;

    def has(self, x: int, y: int) -&gt; bool:
        &#34;&#34;&#34;
        Checks if an intersection contains the given x, y coordinates.
        &#34;&#34;&#34;
        return has(x, y, self.x, self.y, self.length, self.breadth)

    def render(self, zIdx: int):
        &#34;&#34;&#34;
        Draws the intersection on the map.
        &#34;&#34;&#34;
        for x in range(self.x, self.x + self.length):
            for y in range(self.y, self.y + self.breadth):
                drawAlphaCoordBlock(x, y, color=(*GRAY, alphaFromZ(zIdx)))</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="UTM.map.Intersection.corridor1"><code class="name">var <span class="ident">corridor1</span></code></dt>
<dd>
<div class="desc"><p>The first corridor this intersection is a part of.</p></div>
</dd>
<dt id="UTM.map.Intersection.corridor2"><code class="name">var <span class="ident">corridor2</span></code></dt>
<dd>
<div class="desc"><p>The second corridor this intersection is a part of.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="UTM.map.Intersection.has"><code class="name flex">
<span>def <span class="ident">has</span></span>(<span>self, x: int, y: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if an intersection contains the given x, y coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has(self, x: int, y: int) -&gt; bool:
    &#34;&#34;&#34;
    Checks if an intersection contains the given x, y coordinates.
    &#34;&#34;&#34;
    return has(x, y, self.x, self.y, self.length, self.breadth)</code></pre>
</details>
</dd>
<dt id="UTM.map.Intersection.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, zIdx: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the intersection on the map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, zIdx: int):
    &#34;&#34;&#34;
    Draws the intersection on the map.
    &#34;&#34;&#34;
    for x in range(self.x, self.x + self.length):
        for y in range(self.y, self.y + self.breadth):
            drawAlphaCoordBlock(x, y, color=(*GRAY, alphaFromZ(zIdx)))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="UTM.map.Map2D"><code class="flex name class">
<span>class <span class="ident">Map2D</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class representing a 2D Map.
TODO: 2 ways of keeping track of a map: sparse and aircell. Currently Sparse implemented.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Map2D:
    &#34;&#34;&#34;
    A class representing a 2D Map.
    TODO: 2 ways of keeping track of a map: sparse and aircell. Currently Sparse implemented.
    &#34;&#34;&#34;
    def __init__(self):
        self.corridors: list[Corridor2D] = []
        &#34;&#34;&#34;
        A list of all corridors in this map.
        &#34;&#34;&#34;
        self.dimension: Dimension2D = Dimension2D(0, 0)
        &#34;&#34;&#34;
        The Dimensions of this map.
        &#34;&#34;&#34;
        self.intersections: list[Intersection] = []
        &#34;&#34;&#34;
        A list of all the intersections of the map.
        &#34;&#34;&#34;
        self.drones_states: list[DroneState] = []
        &#34;&#34;&#34;
        A list of all the drone states present on the map.
        &#34;&#34;&#34;
        self.agent: Agent = ForwardDroneAgent()
        &#34;&#34;&#34;
        The agent controlling the drone states on the map.
        &#34;&#34;&#34;
        self.dispatchers: list[DispatchVertiport] = []
        &#34;&#34;&#34;
        A list of all the dispatcher vertiports in the map.
        &#34;&#34;&#34;
        self.goals: dict[ReceiveVertiport, list[DroneState]] = dict()
        &#34;&#34;&#34;
        A dictionary mapping all receiving vertiports to all drones that have that vertiport&#39;s coordinates as a goal.
        &#34;&#34;&#34;
        self.comms: CommunicationFabric = CommunicationFabric()
        &#34;&#34;&#34;
        The communication fabric on this map.
        &#34;&#34;&#34;
        self.mems: dict[str, MemoryContext] = dict()
        &#34;&#34;&#34;
        The memory of all drones on this map.
        TODO: encapsulate in drone state
        &#34;&#34;&#34;

    def has(self, x: int, y: int) -&gt; bool:
        &#34;&#34;&#34;
        checks if this given x, y coordinate is in the map bounds.
        &#34;&#34;&#34;
        return has(x,y, 0, 0, self.dimension.width, self.dimension.height)
        
    def get_containing_corridor(self, x: int, y: int) -&gt; Corridor2D:
        &#34;&#34;&#34;
        given an x, y coordinate, returns the corridor that would contain this coordinate or else returns None.
        &#34;&#34;&#34;
        for corridor in self.corridors:
            if corridor.has(x, y):
                return corridor

    def get_containing_intersection(self, x: int, y: int) -&gt; Intersection2D:
        &#34;&#34;&#34;
        given an x, y coordinate, returns the intersection that would contain this coordinate or else returns None.
        &#34;&#34;&#34;
        for intersection in self.intersections:
            if intersection.has(x, y):
                return intersection

    def update_intersections(self):
        &#34;&#34;&#34;
        Called to compute all the intersections on the map given the corridors on this map.
        &#34;&#34;&#34;
        self.intersections = []
        for (a, b) in combinations(self.corridors, 2):
            intersectionBounds = a.getIntersectionBounds(b)
            if intersectionBounds:
                self.intersections += [Intersection(a, b, intersectionBounds)]
    
    def to_arr(self) -&gt; list[list[str]]:
        &#34;&#34;&#34;
        Converts the map to an array representation.
        TODO: describe representation.
        &#34;&#34;&#34;
        map_base = [[&#34;O&#34; for _ in range(self.dimension.width)] for _ in range(self.dimension.height)]
        for corridor in self.corridors:
            if corridor.orientation == Orientation2D.HORIZONTAL:
                for channel in corridor.channels:
                    for i in range(corridor.length):
                        map_base[corridor.y + channel.idx][i + corridor.x] += &#34;&lt;&#34; if channel.dir == &#34;0&#34; else &#34;&gt;&#34;
            elif corridor.orientation == Orientation2D.VERTICAL:
                for channel in corridor.channels:
                    for i in range(corridor.length):
                        map_base[i + corridor.y][corridor.x + channel.idx] += &#34;v&#34; if channel.dir == &#34;1&#34; else &#34;^&#34;
        for intersection in self.intersections:
            for i in range(intersection.length):
                for j in range(intersection.breadth):
                    map_base[intersection.y + j][intersection.x + i] += &#34;@&#34;
        
        return map_base

    def render(self, zIdx: int):
        &#34;&#34;&#34;
        Draws the map onto the screen.
        &#34;&#34;&#34;
        for x in range(self.dimension.width):
            for y in range(self.dimension.height):
                drawAlphaCoordBlock(x, y)

        for corridor in self.corridors:
            corridor.render(zIdx + 1)
        
        for intersection in self.intersections:
            intersection.render(zIdx + 1)

        for drone in self.drones_states:
            drone.render(zIdx + 1)

        for dispatcher in self.dispatchers:
            dispatcher.render(zIdx + 1)

        for x in range(self.dimension.width):
            for y in range(self.dimension.height):
                drawCoordBlock(x, y, color=(*WHITE, alphaFromZ(zIdx)), border=1)
                corridor = self.get_containing_corridor(x, y)
                if corridor:
                    channel = corridor.get_containing_channel(x, y)
                    if channel and not self.get_containing_intersection(x, y):
                        drawArrow(x, y, channel.getDirection())


    def update(self):
        &#34;&#34;&#34;
        Updates all the components on the map.
        &#34;&#34;&#34;
        for drone_state in self.drones_states:
            if  drone_state.goal in self.goals and drone_state.goal.has(drone_state.getCoords().x, drone_state.getCoords().y):
                drone_state.goal.receive(drone_state)
                self.goals[drone_state.goal] = list(filter(lambda e: e != drone_state, self.goals[drone_state.goal]))
                self.drones_states = list(filter(lambda e: e != drone_state, self.drones_states))
                continue
            if drone_state.id not in self.mems:
                self.mems[drone_state.id] = MemoryContext()
            drone_state.applyAction(self.agent.getAction(DroneStateContext(drone_state, self.mems[drone_state.id]), DroneSimContext(drone_state, self)))
            # TODO: have drone push message onto fabric
        
        for dispatcher in self.dispatchers:
            dispatched_drone = dispatcher.dispatch()
            if dispatched_drone:
                self.drones_states += [dispatched_drone]
            dispatcher.update()
        
        self.comms.update()

    def set_global_agent(self, agent: DroneAgent):
        &#34;&#34;&#34;
        Changes the Agents controlling each drone on the simulation.
        &#34;&#34;&#34;
        if isinstance(agent, DroneAgent):
            self.agent = agent
        elif issubclass(agent, DroneAgent):
            self.agent = agent()
    
    def apply_simulation_settings(self, settings):
        &#34;&#34;&#34;
        Applies the given settings onto the simulation.
        TODO: describe the settings dict.
        &#34;&#34;&#34;
        _SIMULATION_SETTINGS_LOOKUP = {
            &#34;global-agent&#34;: lambda e: self.set_global_agent(e)
        }

        for key in settings:
            if key in _SIMULATION_SETTINGS_LOOKUP:
                _SIMULATION_SETTINGS_LOOKUP[key](settings[key])

    def shutdown(self, drone: DroneState):
        &#34;&#34;&#34;
        Shuts down the drone and removes it from the map (if not called here it will still be on the map and will be an error). Furthermore there might be a mem leak.
        &#34;&#34;&#34;
        if drone in self.drones_states:
            drone.shutdown()
            if drone.id in self.mems:
                del self.mems[drone.id]
            self.drones_states.remove(drone)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="UTM.map.Map2D.agent"><code class="name">var <span class="ident">agent</span></code></dt>
<dd>
<div class="desc"><p>The agent controlling the drone states on the map.</p></div>
</dd>
<dt id="UTM.map.Map2D.comms"><code class="name">var <span class="ident">comms</span></code></dt>
<dd>
<div class="desc"><p>The communication fabric on this map.</p></div>
</dd>
<dt id="UTM.map.Map2D.corridors"><code class="name">var <span class="ident">corridors</span></code></dt>
<dd>
<div class="desc"><p>A list of all corridors in this map.</p></div>
</dd>
<dt id="UTM.map.Map2D.dimension"><code class="name">var <span class="ident">dimension</span></code></dt>
<dd>
<div class="desc"><p>The Dimensions of this map.</p></div>
</dd>
<dt id="UTM.map.Map2D.dispatchers"><code class="name">var <span class="ident">dispatchers</span></code></dt>
<dd>
<div class="desc"><p>A list of all the dispatcher vertiports in the map.</p></div>
</dd>
<dt id="UTM.map.Map2D.drones_states"><code class="name">var <span class="ident">drones_states</span></code></dt>
<dd>
<div class="desc"><p>A list of all the drone states present on the map.</p></div>
</dd>
<dt id="UTM.map.Map2D.goals"><code class="name">var <span class="ident">goals</span></code></dt>
<dd>
<div class="desc"><p>A dictionary mapping all receiving vertiports to all drones that have that vertiport's coordinates as a goal.</p></div>
</dd>
<dt id="UTM.map.Map2D.intersections"><code class="name">var <span class="ident">intersections</span></code></dt>
<dd>
<div class="desc"><p>A list of all the intersections of the map.</p></div>
</dd>
<dt id="UTM.map.Map2D.mems"><code class="name">var <span class="ident">mems</span></code></dt>
<dd>
<div class="desc"><p>The memory of all drones on this map.
TODO: encapsulate in drone state</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="UTM.map.Map2D.apply_simulation_settings"><code class="name flex">
<span>def <span class="ident">apply_simulation_settings</span></span>(<span>self, settings)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the given settings onto the simulation.
TODO: describe the settings dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_simulation_settings(self, settings):
    &#34;&#34;&#34;
    Applies the given settings onto the simulation.
    TODO: describe the settings dict.
    &#34;&#34;&#34;
    _SIMULATION_SETTINGS_LOOKUP = {
        &#34;global-agent&#34;: lambda e: self.set_global_agent(e)
    }

    for key in settings:
        if key in _SIMULATION_SETTINGS_LOOKUP:
            _SIMULATION_SETTINGS_LOOKUP[key](settings[key])</code></pre>
</details>
</dd>
<dt id="UTM.map.Map2D.get_containing_corridor"><code class="name flex">
<span>def <span class="ident">get_containing_corridor</span></span>(<span>self, x: int, y: int) ‑> <a title="UTM.map.Corridor2D" href="#UTM.map.Corridor2D">Corridor2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>given an x, y coordinate, returns the corridor that would contain this coordinate or else returns None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_containing_corridor(self, x: int, y: int) -&gt; Corridor2D:
    &#34;&#34;&#34;
    given an x, y coordinate, returns the corridor that would contain this coordinate or else returns None.
    &#34;&#34;&#34;
    for corridor in self.corridors:
        if corridor.has(x, y):
            return corridor</code></pre>
</details>
</dd>
<dt id="UTM.map.Map2D.get_containing_intersection"><code class="name flex">
<span>def <span class="ident">get_containing_intersection</span></span>(<span>self, x: int, y: int) ‑> Intersection2D</span>
</code></dt>
<dd>
<div class="desc"><p>given an x, y coordinate, returns the intersection that would contain this coordinate or else returns None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_containing_intersection(self, x: int, y: int) -&gt; Intersection2D:
    &#34;&#34;&#34;
    given an x, y coordinate, returns the intersection that would contain this coordinate or else returns None.
    &#34;&#34;&#34;
    for intersection in self.intersections:
        if intersection.has(x, y):
            return intersection</code></pre>
</details>
</dd>
<dt id="UTM.map.Map2D.has"><code class="name flex">
<span>def <span class="ident">has</span></span>(<span>self, x: int, y: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>checks if this given x, y coordinate is in the map bounds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has(self, x: int, y: int) -&gt; bool:
    &#34;&#34;&#34;
    checks if this given x, y coordinate is in the map bounds.
    &#34;&#34;&#34;
    return has(x,y, 0, 0, self.dimension.width, self.dimension.height)</code></pre>
</details>
</dd>
<dt id="UTM.map.Map2D.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, zIdx: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the map onto the screen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, zIdx: int):
    &#34;&#34;&#34;
    Draws the map onto the screen.
    &#34;&#34;&#34;
    for x in range(self.dimension.width):
        for y in range(self.dimension.height):
            drawAlphaCoordBlock(x, y)

    for corridor in self.corridors:
        corridor.render(zIdx + 1)
    
    for intersection in self.intersections:
        intersection.render(zIdx + 1)

    for drone in self.drones_states:
        drone.render(zIdx + 1)

    for dispatcher in self.dispatchers:
        dispatcher.render(zIdx + 1)

    for x in range(self.dimension.width):
        for y in range(self.dimension.height):
            drawCoordBlock(x, y, color=(*WHITE, alphaFromZ(zIdx)), border=1)
            corridor = self.get_containing_corridor(x, y)
            if corridor:
                channel = corridor.get_containing_channel(x, y)
                if channel and not self.get_containing_intersection(x, y):
                    drawArrow(x, y, channel.getDirection())</code></pre>
</details>
</dd>
<dt id="UTM.map.Map2D.set_global_agent"><code class="name flex">
<span>def <span class="ident">set_global_agent</span></span>(<span>self, agent: DroneAgent)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes the Agents controlling each drone on the simulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_global_agent(self, agent: DroneAgent):
    &#34;&#34;&#34;
    Changes the Agents controlling each drone on the simulation.
    &#34;&#34;&#34;
    if isinstance(agent, DroneAgent):
        self.agent = agent
    elif issubclass(agent, DroneAgent):
        self.agent = agent()</code></pre>
</details>
</dd>
<dt id="UTM.map.Map2D.shutdown"><code class="name flex">
<span>def <span class="ident">shutdown</span></span>(<span>self, drone: DroneState)</span>
</code></dt>
<dd>
<div class="desc"><p>Shuts down the drone and removes it from the map (if not called here it will still be on the map and will be an error). Furthermore there might be a mem leak.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shutdown(self, drone: DroneState):
    &#34;&#34;&#34;
    Shuts down the drone and removes it from the map (if not called here it will still be on the map and will be an error). Furthermore there might be a mem leak.
    &#34;&#34;&#34;
    if drone in self.drones_states:
        drone.shutdown()
        if drone.id in self.mems:
            del self.mems[drone.id]
        self.drones_states.remove(drone)</code></pre>
</details>
</dd>
<dt id="UTM.map.Map2D.to_arr"><code class="name flex">
<span>def <span class="ident">to_arr</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the map to an array representation.
TODO: describe representation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_arr(self) -&gt; list[list[str]]:
    &#34;&#34;&#34;
    Converts the map to an array representation.
    TODO: describe representation.
    &#34;&#34;&#34;
    map_base = [[&#34;O&#34; for _ in range(self.dimension.width)] for _ in range(self.dimension.height)]
    for corridor in self.corridors:
        if corridor.orientation == Orientation2D.HORIZONTAL:
            for channel in corridor.channels:
                for i in range(corridor.length):
                    map_base[corridor.y + channel.idx][i + corridor.x] += &#34;&lt;&#34; if channel.dir == &#34;0&#34; else &#34;&gt;&#34;
        elif corridor.orientation == Orientation2D.VERTICAL:
            for channel in corridor.channels:
                for i in range(corridor.length):
                    map_base[i + corridor.y][corridor.x + channel.idx] += &#34;v&#34; if channel.dir == &#34;1&#34; else &#34;^&#34;
    for intersection in self.intersections:
        for i in range(intersection.length):
            for j in range(intersection.breadth):
                map_base[intersection.y + j][intersection.x + i] += &#34;@&#34;
    
    return map_base</code></pre>
</details>
</dd>
<dt id="UTM.map.Map2D.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates all the components on the map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34;
    Updates all the components on the map.
    &#34;&#34;&#34;
    for drone_state in self.drones_states:
        if  drone_state.goal in self.goals and drone_state.goal.has(drone_state.getCoords().x, drone_state.getCoords().y):
            drone_state.goal.receive(drone_state)
            self.goals[drone_state.goal] = list(filter(lambda e: e != drone_state, self.goals[drone_state.goal]))
            self.drones_states = list(filter(lambda e: e != drone_state, self.drones_states))
            continue
        if drone_state.id not in self.mems:
            self.mems[drone_state.id] = MemoryContext()
        drone_state.applyAction(self.agent.getAction(DroneStateContext(drone_state, self.mems[drone_state.id]), DroneSimContext(drone_state, self)))
        # TODO: have drone push message onto fabric
    
    for dispatcher in self.dispatchers:
        dispatched_drone = dispatcher.dispatch()
        if dispatched_drone:
            self.drones_states += [dispatched_drone]
        dispatcher.update()
    
    self.comms.update()</code></pre>
</details>
</dd>
<dt id="UTM.map.Map2D.update_intersections"><code class="name flex">
<span>def <span class="ident">update_intersections</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called to compute all the intersections on the map given the corridors on this map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_intersections(self):
    &#34;&#34;&#34;
    Called to compute all the intersections on the map given the corridors on this map.
    &#34;&#34;&#34;
    self.intersections = []
    for (a, b) in combinations(self.corridors, 2):
        intersectionBounds = a.getIntersectionBounds(b)
        if intersectionBounds:
            self.intersections += [Intersection(a, b, intersectionBounds)]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="UTM" href="index.html">UTM</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="UTM.map.Channel2D" href="#UTM.map.Channel2D">Channel2D</a></code></h4>
<ul class="">
<li><code><a title="UTM.map.Channel2D.dir" href="#UTM.map.Channel2D.dir">dir</a></code></li>
<li><code><a title="UTM.map.Channel2D.getDirection" href="#UTM.map.Channel2D.getDirection">getDirection</a></code></li>
<li><code><a title="UTM.map.Channel2D.idx" href="#UTM.map.Channel2D.idx">idx</a></code></li>
<li><code><a title="UTM.map.Channel2D.orientation" href="#UTM.map.Channel2D.orientation">orientation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UTM.map.Corridor2D" href="#UTM.map.Corridor2D">Corridor2D</a></code></h4>
<ul class="">
<li><code><a title="UTM.map.Corridor2D.channels" href="#UTM.map.Corridor2D.channels">channels</a></code></li>
<li><code><a title="UTM.map.Corridor2D.getIntersectionBounds" href="#UTM.map.Corridor2D.getIntersectionBounds">getIntersectionBounds</a></code></li>
<li><code><a title="UTM.map.Corridor2D.getRectangle" href="#UTM.map.Corridor2D.getRectangle">getRectangle</a></code></li>
<li><code><a title="UTM.map.Corridor2D.get_containing_channel" href="#UTM.map.Corridor2D.get_containing_channel">get_containing_channel</a></code></li>
<li><code><a title="UTM.map.Corridor2D.has" href="#UTM.map.Corridor2D.has">has</a></code></li>
<li><code><a title="UTM.map.Corridor2D.intersects" href="#UTM.map.Corridor2D.intersects">intersects</a></code></li>
<li><code><a title="UTM.map.Corridor2D.length" href="#UTM.map.Corridor2D.length">length</a></code></li>
<li><code><a title="UTM.map.Corridor2D.orientation" href="#UTM.map.Corridor2D.orientation">orientation</a></code></li>
<li><code><a title="UTM.map.Corridor2D.render" href="#UTM.map.Corridor2D.render">render</a></code></li>
<li><code><a title="UTM.map.Corridor2D.width" href="#UTM.map.Corridor2D.width">width</a></code></li>
<li><code><a title="UTM.map.Corridor2D.x" href="#UTM.map.Corridor2D.x">x</a></code></li>
<li><code><a title="UTM.map.Corridor2D.y" href="#UTM.map.Corridor2D.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UTM.map.Intersection" href="#UTM.map.Intersection">Intersection</a></code></h4>
<ul class="">
<li><code><a title="UTM.map.Intersection.corridor1" href="#UTM.map.Intersection.corridor1">corridor1</a></code></li>
<li><code><a title="UTM.map.Intersection.corridor2" href="#UTM.map.Intersection.corridor2">corridor2</a></code></li>
<li><code><a title="UTM.map.Intersection.has" href="#UTM.map.Intersection.has">has</a></code></li>
<li><code><a title="UTM.map.Intersection.render" href="#UTM.map.Intersection.render">render</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UTM.map.Map2D" href="#UTM.map.Map2D">Map2D</a></code></h4>
<ul class="">
<li><code><a title="UTM.map.Map2D.agent" href="#UTM.map.Map2D.agent">agent</a></code></li>
<li><code><a title="UTM.map.Map2D.apply_simulation_settings" href="#UTM.map.Map2D.apply_simulation_settings">apply_simulation_settings</a></code></li>
<li><code><a title="UTM.map.Map2D.comms" href="#UTM.map.Map2D.comms">comms</a></code></li>
<li><code><a title="UTM.map.Map2D.corridors" href="#UTM.map.Map2D.corridors">corridors</a></code></li>
<li><code><a title="UTM.map.Map2D.dimension" href="#UTM.map.Map2D.dimension">dimension</a></code></li>
<li><code><a title="UTM.map.Map2D.dispatchers" href="#UTM.map.Map2D.dispatchers">dispatchers</a></code></li>
<li><code><a title="UTM.map.Map2D.drones_states" href="#UTM.map.Map2D.drones_states">drones_states</a></code></li>
<li><code><a title="UTM.map.Map2D.get_containing_corridor" href="#UTM.map.Map2D.get_containing_corridor">get_containing_corridor</a></code></li>
<li><code><a title="UTM.map.Map2D.get_containing_intersection" href="#UTM.map.Map2D.get_containing_intersection">get_containing_intersection</a></code></li>
<li><code><a title="UTM.map.Map2D.goals" href="#UTM.map.Map2D.goals">goals</a></code></li>
<li><code><a title="UTM.map.Map2D.has" href="#UTM.map.Map2D.has">has</a></code></li>
<li><code><a title="UTM.map.Map2D.intersections" href="#UTM.map.Map2D.intersections">intersections</a></code></li>
<li><code><a title="UTM.map.Map2D.mems" href="#UTM.map.Map2D.mems">mems</a></code></li>
<li><code><a title="UTM.map.Map2D.render" href="#UTM.map.Map2D.render">render</a></code></li>
<li><code><a title="UTM.map.Map2D.set_global_agent" href="#UTM.map.Map2D.set_global_agent">set_global_agent</a></code></li>
<li><code><a title="UTM.map.Map2D.shutdown" href="#UTM.map.Map2D.shutdown">shutdown</a></code></li>
<li><code><a title="UTM.map.Map2D.to_arr" href="#UTM.map.Map2D.to_arr">to_arr</a></code></li>
<li><code><a title="UTM.map.Map2D.update" href="#UTM.map.Map2D.update">update</a></code></li>
<li><code><a title="UTM.map.Map2D.update_intersections" href="#UTM.map.Map2D.update_intersections">update_intersections</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>