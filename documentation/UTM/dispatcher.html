<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>UTM.dispatcher API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/atom-one-dark.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>UTM.dispatcher</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># forward declare types
from __future__ import annotations

from random import randint
from constants import WHITE, RNG, MovementVector2D
from computed import alphaFromZ
from drone import DroneState
from render_util import drawAlphaCoordBlock

class BinaryProbabilityDistribution:
    &#34;&#34;&#34;
    A BinaryProbabilityDistribution is a class that will help generate a sequenece of boolean values of true and false.
    &#34;&#34;&#34;
    def tick(self) -&gt; bool:
        &#34;&#34;&#34;
        Abstract:
        Every time this function is called, the generator will generate a new boolean value.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;Drone Generator not implemented&#34;)

class BinaryPeriodicDistribution(BinaryProbabilityDistribution):
    &#34;&#34;&#34;
    A BinaryPeriodicDistribution will generate a single true over a period given a probability value.
    A seed can optionally be provieded to control the sequence generated. 
    &#34;&#34;&#34;
    def __init__(self, period: float, prob:float = 0.6, seed:int =randint(0, 10000)):
        self.period: float = period
        &#34;&#34;&#34;
        The interval length for one true value.
        &#34;&#34;&#34;
        self.prob: float = prob
        &#34;&#34;&#34;
        The probability with which the true will be generated over that period.
        &#34;&#34;&#34;
        self.seed: int = seed
        &#34;&#34;&#34;
        The seed that this generator is based on.
        &#34;&#34;&#34;
        self.rng: RNG = RNG(seed)
        &#34;&#34;&#34;
        The random number generator to generate a sequence of random numbers that will be converted to a boolean distribution.
        &#34;&#34;&#34;
        self.iter: int = 0
        &#34;&#34;&#34;
        Number of iterations that have passed (to keep track of the period).
        &#34;&#34;&#34;
        self.last_iter: int = 0
        &#34;&#34;&#34;
        Number of iterations that have passed since last generation (to keep track of the period).
        &#34;&#34;&#34;

    def tick(self) -&gt; bool:
        &#34;&#34;&#34;
        If the difference in the iter and last_iter is greater than or equal to the period, it will attempt to generate a True with the given probability.
        &#34;&#34;&#34;
        if (self.iter - self.last_iter &gt;= self.period):
            self.last_iter = self.iter
            if (self.rng.randint(0, 100) &lt; self.prob * 100):
                return True
        return False

    def update(self): 
        &#34;&#34;&#34;
        Called to keep track of the number of iterations that have passed in the simulation to keep track of the period.
        &#34;&#34;&#34;
        self.iter += 1


# potentially queue up multiple drones with different priorities and speeds etc
# generator just indicates if a drone has to be made, dispatch unit actually sets the drone up
# places drone at the correct starting point
class DispatchVertiport:
    &#34;&#34;&#34;
    Currently Dispatch Vertiports serve to provide a form of traffic generation.
    Given a coordinate, a priority and a direction, dispatch vertiports generate drones with those attributes.
    
    Dispatch Units are powered by DroneGenerators, that can have different probabilistic distributions powering them.
    The main working is, the unit will tick the generator every iteration, and if the tick returns true it will dispatch a drone on the map.

    TODO: add drone destination properties.
    TODO: look into -&gt; joby aviation, Bell Labs
    &#34;&#34;&#34;
    def __init__(self, x: int, y: int, dir: Direction2D, priority: int = 0, generator: BinaryProbabilityDistribution = BinaryPeriodicDistribution(5), name: str =&#34;Dispatch Unit&#34;):
        self.x: int = x
        &#34;&#34;&#34;
        x coordinate of the vertiport on the map.
        &#34;&#34;&#34;
        self.y: int = y
        &#34;&#34;&#34;
        y coordinate of the vertiport on the map.
        &#34;&#34;&#34;
        self.dir: Direction2D = dir
        &#34;&#34;&#34;
        direction that the drones are spawned in.
        &#34;&#34;&#34;
        self.priority: int = priority
        &#34;&#34;&#34;
        priority of the drones spawned in.
        &#34;&#34;&#34;
        self.count: int = 0
        &#34;&#34;&#34;
        keeps track of how many drones are spawned by this vertiport.
        &#34;&#34;&#34;
        self.generator: BinaryProbabilityDistribution = generator
        &#34;&#34;&#34;
        A DroneGenerator that has a probabilistic model to allow this dispatch unit to spawn drones.
        &#34;&#34;&#34;
        self.name: str = name
        &#34;&#34;&#34;
        Name of this dispatch unit.
        &#34;&#34;&#34;

    def dispatch(self) -&gt; DroneState:
        if self.generator.tick():
            self.count += 1
            return DroneState(MovementVector2D(self.x, self.y, self.dir), prioirty=self.priority, name=f&#34;{self.name}-{self.count}&#34;)

    def render(self, zIdx: int):
        drawAlphaCoordBlock(self.x, self.y, (*WHITE, alphaFromZ(zIdx)), border=5)

    def update(self):
        self.generator.update()
        
# marks drone as received/ goals are set to receive units/ will fire drone&#39;s graceful shutdown
# not a separate command in the map file format, will be created as new goals are created
class ReceiveVertiport:
    &#34;&#34;&#34;
    Receive vertiports are the opposite of dispatch vertiports, they will receive drones if the drone goal matches the receive vertiport.
    The drone goal can currently only be a receive vertiport&#39;s coordinates, or it can be out of bounds for the map to pick up once the drone goes offscreent.
    &#34;&#34;&#34;
    def __init__(self, x: int, y: int):
        self.x: int = x
        &#34;&#34;&#34;
        The x coordinate of the receive vertiport.
        &#34;&#34;&#34;
        self.y: int = y
        &#34;&#34;&#34;
        The y coordinate of the receive vertiport.
        &#34;&#34;&#34;
        self.ref_count: int = 0
        &#34;&#34;&#34;
        The number of drones this vertiport has received.
        &#34;&#34;&#34;

    def __eq__(self, other: ReceiveVertiport):
        &#34;&#34;&#34;
        Compares two receive vertiports on the basis that their coordinates are equal.
        &#34;&#34;&#34;
        if type(other) == type(self):
            return self.x == other.x and self.y == other.y
        return False

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;
        Hashes the vertiports to ensure that 2 vertiports that are equal will have the same hash.
        &#34;&#34;&#34;
        return hash((self.x, self.y))

    def receive(self, drone: DroneState):
        &#34;&#34;&#34;
        Will gracefully shutdown the drone and then update its reference count, given that this vertiport was the drone&#39;s goal.
        &#34;&#34;&#34;
        drone.shutdown()
        self.ref_count += 1
    
    def has(self, x: int, y: int) -&gt; bool:
        &#34;&#34;&#34;
        Will check if the vertiport is at the given x and y coordinate.
        &#34;&#34;&#34;
        return x == self.x and y == self.y</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="UTM.dispatcher.BinaryPeriodicDistribution"><code class="flex name class">
<span>class <span class="ident">BinaryPeriodicDistribution</span></span>
<span>(</span><span>period: float, prob: float = 0.6, seed: int = 5842)</span>
</code></dt>
<dd>
<div class="desc"><p>A BinaryPeriodicDistribution will generate a single true over a period given a probability value.
A seed can optionally be provieded to control the sequence generated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BinaryPeriodicDistribution(BinaryProbabilityDistribution):
    &#34;&#34;&#34;
    A BinaryPeriodicDistribution will generate a single true over a period given a probability value.
    A seed can optionally be provieded to control the sequence generated. 
    &#34;&#34;&#34;
    def __init__(self, period: float, prob:float = 0.6, seed:int =randint(0, 10000)):
        self.period: float = period
        &#34;&#34;&#34;
        The interval length for one true value.
        &#34;&#34;&#34;
        self.prob: float = prob
        &#34;&#34;&#34;
        The probability with which the true will be generated over that period.
        &#34;&#34;&#34;
        self.seed: int = seed
        &#34;&#34;&#34;
        The seed that this generator is based on.
        &#34;&#34;&#34;
        self.rng: RNG = RNG(seed)
        &#34;&#34;&#34;
        The random number generator to generate a sequence of random numbers that will be converted to a boolean distribution.
        &#34;&#34;&#34;
        self.iter: int = 0
        &#34;&#34;&#34;
        Number of iterations that have passed (to keep track of the period).
        &#34;&#34;&#34;
        self.last_iter: int = 0
        &#34;&#34;&#34;
        Number of iterations that have passed since last generation (to keep track of the period).
        &#34;&#34;&#34;

    def tick(self) -&gt; bool:
        &#34;&#34;&#34;
        If the difference in the iter and last_iter is greater than or equal to the period, it will attempt to generate a True with the given probability.
        &#34;&#34;&#34;
        if (self.iter - self.last_iter &gt;= self.period):
            self.last_iter = self.iter
            if (self.rng.randint(0, 100) &lt; self.prob * 100):
                return True
        return False

    def update(self): 
        &#34;&#34;&#34;
        Called to keep track of the number of iterations that have passed in the simulation to keep track of the period.
        &#34;&#34;&#34;
        self.iter += 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="UTM.dispatcher.BinaryProbabilityDistribution" href="#UTM.dispatcher.BinaryProbabilityDistribution">BinaryProbabilityDistribution</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="UTM.dispatcher.BinaryPeriodicDistribution.iter"><code class="name">var <span class="ident">iter</span></code></dt>
<dd>
<div class="desc"><p>Number of iterations that have passed (to keep track of the period).</p></div>
</dd>
<dt id="UTM.dispatcher.BinaryPeriodicDistribution.last_iter"><code class="name">var <span class="ident">last_iter</span></code></dt>
<dd>
<div class="desc"><p>Number of iterations that have passed since last generation (to keep track of the period).</p></div>
</dd>
<dt id="UTM.dispatcher.BinaryPeriodicDistribution.period"><code class="name">var <span class="ident">period</span></code></dt>
<dd>
<div class="desc"><p>The interval length for one true value.</p></div>
</dd>
<dt id="UTM.dispatcher.BinaryPeriodicDistribution.prob"><code class="name">var <span class="ident">prob</span></code></dt>
<dd>
<div class="desc"><p>The probability with which the true will be generated over that period.</p></div>
</dd>
<dt id="UTM.dispatcher.BinaryPeriodicDistribution.rng"><code class="name">var <span class="ident">rng</span></code></dt>
<dd>
<div class="desc"><p>The random number generator to generate a sequence of random numbers that will be converted to a boolean distribution.</p></div>
</dd>
<dt id="UTM.dispatcher.BinaryPeriodicDistribution.seed"><code class="name">var <span class="ident">seed</span></code></dt>
<dd>
<div class="desc"><p>The seed that this generator is based on.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="UTM.dispatcher.BinaryPeriodicDistribution.tick"><code class="name flex">
<span>def <span class="ident">tick</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>If the difference in the iter and last_iter is greater than or equal to the period, it will attempt to generate a True with the given probability.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tick(self) -&gt; bool:
    &#34;&#34;&#34;
    If the difference in the iter and last_iter is greater than or equal to the period, it will attempt to generate a True with the given probability.
    &#34;&#34;&#34;
    if (self.iter - self.last_iter &gt;= self.period):
        self.last_iter = self.iter
        if (self.rng.randint(0, 100) &lt; self.prob * 100):
            return True
    return False</code></pre>
</details>
</dd>
<dt id="UTM.dispatcher.BinaryPeriodicDistribution.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called to keep track of the number of iterations that have passed in the simulation to keep track of the period.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self): 
    &#34;&#34;&#34;
    Called to keep track of the number of iterations that have passed in the simulation to keep track of the period.
    &#34;&#34;&#34;
    self.iter += 1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="UTM.dispatcher.BinaryProbabilityDistribution"><code class="flex name class">
<span>class <span class="ident">BinaryProbabilityDistribution</span></span>
</code></dt>
<dd>
<div class="desc"><p>A BinaryProbabilityDistribution is a class that will help generate a sequenece of boolean values of true and false.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BinaryProbabilityDistribution:
    &#34;&#34;&#34;
    A BinaryProbabilityDistribution is a class that will help generate a sequenece of boolean values of true and false.
    &#34;&#34;&#34;
    def tick(self) -&gt; bool:
        &#34;&#34;&#34;
        Abstract:
        Every time this function is called, the generator will generate a new boolean value.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;Drone Generator not implemented&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="UTM.dispatcher.BinaryPeriodicDistribution" href="#UTM.dispatcher.BinaryPeriodicDistribution">BinaryPeriodicDistribution</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="UTM.dispatcher.BinaryProbabilityDistribution.tick"><code class="name flex">
<span>def <span class="ident">tick</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract:
Every time this function is called, the generator will generate a new boolean value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tick(self) -&gt; bool:
    &#34;&#34;&#34;
    Abstract:
    Every time this function is called, the generator will generate a new boolean value.
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;Drone Generator not implemented&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="UTM.dispatcher.DispatchVertiport"><code class="flex name class">
<span>class <span class="ident">DispatchVertiport</span></span>
<span>(</span><span>x: int, y: int, dir: Direction2D, priority: int = 0, generator: <a title="UTM.dispatcher.BinaryProbabilityDistribution" href="#UTM.dispatcher.BinaryProbabilityDistribution">BinaryProbabilityDistribution</a> = &lt;UTM.dispatcher.BinaryPeriodicDistribution object&gt;, name: str = 'Dispatch Unit')</span>
</code></dt>
<dd>
<div class="desc"><p>Currently Dispatch Vertiports serve to provide a form of traffic generation.
Given a coordinate, a priority and a direction, dispatch vertiports generate drones with those attributes.</p>
<p>Dispatch Units are powered by DroneGenerators, that can have different probabilistic distributions powering them.
The main working is, the unit will tick the generator every iteration, and if the tick returns true it will dispatch a drone on the map.</p>
<p>TODO: add drone destination properties.
TODO: look into -&gt; joby aviation, Bell Labs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DispatchVertiport:
    &#34;&#34;&#34;
    Currently Dispatch Vertiports serve to provide a form of traffic generation.
    Given a coordinate, a priority and a direction, dispatch vertiports generate drones with those attributes.
    
    Dispatch Units are powered by DroneGenerators, that can have different probabilistic distributions powering them.
    The main working is, the unit will tick the generator every iteration, and if the tick returns true it will dispatch a drone on the map.

    TODO: add drone destination properties.
    TODO: look into -&gt; joby aviation, Bell Labs
    &#34;&#34;&#34;
    def __init__(self, x: int, y: int, dir: Direction2D, priority: int = 0, generator: BinaryProbabilityDistribution = BinaryPeriodicDistribution(5), name: str =&#34;Dispatch Unit&#34;):
        self.x: int = x
        &#34;&#34;&#34;
        x coordinate of the vertiport on the map.
        &#34;&#34;&#34;
        self.y: int = y
        &#34;&#34;&#34;
        y coordinate of the vertiport on the map.
        &#34;&#34;&#34;
        self.dir: Direction2D = dir
        &#34;&#34;&#34;
        direction that the drones are spawned in.
        &#34;&#34;&#34;
        self.priority: int = priority
        &#34;&#34;&#34;
        priority of the drones spawned in.
        &#34;&#34;&#34;
        self.count: int = 0
        &#34;&#34;&#34;
        keeps track of how many drones are spawned by this vertiport.
        &#34;&#34;&#34;
        self.generator: BinaryProbabilityDistribution = generator
        &#34;&#34;&#34;
        A DroneGenerator that has a probabilistic model to allow this dispatch unit to spawn drones.
        &#34;&#34;&#34;
        self.name: str = name
        &#34;&#34;&#34;
        Name of this dispatch unit.
        &#34;&#34;&#34;

    def dispatch(self) -&gt; DroneState:
        if self.generator.tick():
            self.count += 1
            return DroneState(MovementVector2D(self.x, self.y, self.dir), prioirty=self.priority, name=f&#34;{self.name}-{self.count}&#34;)

    def render(self, zIdx: int):
        drawAlphaCoordBlock(self.x, self.y, (*WHITE, alphaFromZ(zIdx)), border=5)

    def update(self):
        self.generator.update()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="UTM.dispatcher.DispatchVertiport.count"><code class="name">var <span class="ident">count</span></code></dt>
<dd>
<div class="desc"><p>keeps track of how many drones are spawned by this vertiport.</p></div>
</dd>
<dt id="UTM.dispatcher.DispatchVertiport.dir"><code class="name">var <span class="ident">dir</span></code></dt>
<dd>
<div class="desc"><p>direction that the drones are spawned in.</p></div>
</dd>
<dt id="UTM.dispatcher.DispatchVertiport.generator"><code class="name">var <span class="ident">generator</span></code></dt>
<dd>
<div class="desc"><p>A DroneGenerator that has a probabilistic model to allow this dispatch unit to spawn drones.</p></div>
</dd>
<dt id="UTM.dispatcher.DispatchVertiport.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of this dispatch unit.</p></div>
</dd>
<dt id="UTM.dispatcher.DispatchVertiport.priority"><code class="name">var <span class="ident">priority</span></code></dt>
<dd>
<div class="desc"><p>priority of the drones spawned in.</p></div>
</dd>
<dt id="UTM.dispatcher.DispatchVertiport.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<div class="desc"><p>x coordinate of the vertiport on the map.</p></div>
</dd>
<dt id="UTM.dispatcher.DispatchVertiport.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<div class="desc"><p>y coordinate of the vertiport on the map.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="UTM.dispatcher.DispatchVertiport.dispatch"><code class="name flex">
<span>def <span class="ident">dispatch</span></span>(<span>self) ‑> drone.DroneState</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispatch(self) -&gt; DroneState:
    if self.generator.tick():
        self.count += 1
        return DroneState(MovementVector2D(self.x, self.y, self.dir), prioirty=self.priority, name=f&#34;{self.name}-{self.count}&#34;)</code></pre>
</details>
</dd>
<dt id="UTM.dispatcher.DispatchVertiport.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, zIdx: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, zIdx: int):
    drawAlphaCoordBlock(self.x, self.y, (*WHITE, alphaFromZ(zIdx)), border=5)</code></pre>
</details>
</dd>
<dt id="UTM.dispatcher.DispatchVertiport.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    self.generator.update()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="UTM.dispatcher.ReceiveVertiport"><code class="flex name class">
<span>class <span class="ident">ReceiveVertiport</span></span>
<span>(</span><span>x: int, y: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Receive vertiports are the opposite of dispatch vertiports, they will receive drones if the drone goal matches the receive vertiport.
The drone goal can currently only be a receive vertiport's coordinates, or it can be out of bounds for the map to pick up once the drone goes offscreent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReceiveVertiport:
    &#34;&#34;&#34;
    Receive vertiports are the opposite of dispatch vertiports, they will receive drones if the drone goal matches the receive vertiport.
    The drone goal can currently only be a receive vertiport&#39;s coordinates, or it can be out of bounds for the map to pick up once the drone goes offscreent.
    &#34;&#34;&#34;
    def __init__(self, x: int, y: int):
        self.x: int = x
        &#34;&#34;&#34;
        The x coordinate of the receive vertiport.
        &#34;&#34;&#34;
        self.y: int = y
        &#34;&#34;&#34;
        The y coordinate of the receive vertiport.
        &#34;&#34;&#34;
        self.ref_count: int = 0
        &#34;&#34;&#34;
        The number of drones this vertiport has received.
        &#34;&#34;&#34;

    def __eq__(self, other: ReceiveVertiport):
        &#34;&#34;&#34;
        Compares two receive vertiports on the basis that their coordinates are equal.
        &#34;&#34;&#34;
        if type(other) == type(self):
            return self.x == other.x and self.y == other.y
        return False

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;
        Hashes the vertiports to ensure that 2 vertiports that are equal will have the same hash.
        &#34;&#34;&#34;
        return hash((self.x, self.y))

    def receive(self, drone: DroneState):
        &#34;&#34;&#34;
        Will gracefully shutdown the drone and then update its reference count, given that this vertiport was the drone&#39;s goal.
        &#34;&#34;&#34;
        drone.shutdown()
        self.ref_count += 1
    
    def has(self, x: int, y: int) -&gt; bool:
        &#34;&#34;&#34;
        Will check if the vertiport is at the given x and y coordinate.
        &#34;&#34;&#34;
        return x == self.x and y == self.y</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="UTM.dispatcher.ReceiveVertiport.ref_count"><code class="name">var <span class="ident">ref_count</span></code></dt>
<dd>
<div class="desc"><p>The number of drones this vertiport has received.</p></div>
</dd>
<dt id="UTM.dispatcher.ReceiveVertiport.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<div class="desc"><p>The x coordinate of the receive vertiport.</p></div>
</dd>
<dt id="UTM.dispatcher.ReceiveVertiport.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<div class="desc"><p>The y coordinate of the receive vertiport.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="UTM.dispatcher.ReceiveVertiport.has"><code class="name flex">
<span>def <span class="ident">has</span></span>(<span>self, x: int, y: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Will check if the vertiport is at the given x and y coordinate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has(self, x: int, y: int) -&gt; bool:
    &#34;&#34;&#34;
    Will check if the vertiport is at the given x and y coordinate.
    &#34;&#34;&#34;
    return x == self.x and y == self.y</code></pre>
</details>
</dd>
<dt id="UTM.dispatcher.ReceiveVertiport.receive"><code class="name flex">
<span>def <span class="ident">receive</span></span>(<span>self, drone: DroneState)</span>
</code></dt>
<dd>
<div class="desc"><p>Will gracefully shutdown the drone and then update its reference count, given that this vertiport was the drone's goal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def receive(self, drone: DroneState):
    &#34;&#34;&#34;
    Will gracefully shutdown the drone and then update its reference count, given that this vertiport was the drone&#39;s goal.
    &#34;&#34;&#34;
    drone.shutdown()
    self.ref_count += 1</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="UTM" href="index.html">UTM</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="UTM.dispatcher.BinaryPeriodicDistribution" href="#UTM.dispatcher.BinaryPeriodicDistribution">BinaryPeriodicDistribution</a></code></h4>
<ul class="two-column">
<li><code><a title="UTM.dispatcher.BinaryPeriodicDistribution.iter" href="#UTM.dispatcher.BinaryPeriodicDistribution.iter">iter</a></code></li>
<li><code><a title="UTM.dispatcher.BinaryPeriodicDistribution.last_iter" href="#UTM.dispatcher.BinaryPeriodicDistribution.last_iter">last_iter</a></code></li>
<li><code><a title="UTM.dispatcher.BinaryPeriodicDistribution.period" href="#UTM.dispatcher.BinaryPeriodicDistribution.period">period</a></code></li>
<li><code><a title="UTM.dispatcher.BinaryPeriodicDistribution.prob" href="#UTM.dispatcher.BinaryPeriodicDistribution.prob">prob</a></code></li>
<li><code><a title="UTM.dispatcher.BinaryPeriodicDistribution.rng" href="#UTM.dispatcher.BinaryPeriodicDistribution.rng">rng</a></code></li>
<li><code><a title="UTM.dispatcher.BinaryPeriodicDistribution.seed" href="#UTM.dispatcher.BinaryPeriodicDistribution.seed">seed</a></code></li>
<li><code><a title="UTM.dispatcher.BinaryPeriodicDistribution.tick" href="#UTM.dispatcher.BinaryPeriodicDistribution.tick">tick</a></code></li>
<li><code><a title="UTM.dispatcher.BinaryPeriodicDistribution.update" href="#UTM.dispatcher.BinaryPeriodicDistribution.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UTM.dispatcher.BinaryProbabilityDistribution" href="#UTM.dispatcher.BinaryProbabilityDistribution">BinaryProbabilityDistribution</a></code></h4>
<ul class="">
<li><code><a title="UTM.dispatcher.BinaryProbabilityDistribution.tick" href="#UTM.dispatcher.BinaryProbabilityDistribution.tick">tick</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UTM.dispatcher.DispatchVertiport" href="#UTM.dispatcher.DispatchVertiport">DispatchVertiport</a></code></h4>
<ul class="two-column">
<li><code><a title="UTM.dispatcher.DispatchVertiport.count" href="#UTM.dispatcher.DispatchVertiport.count">count</a></code></li>
<li><code><a title="UTM.dispatcher.DispatchVertiport.dir" href="#UTM.dispatcher.DispatchVertiport.dir">dir</a></code></li>
<li><code><a title="UTM.dispatcher.DispatchVertiport.dispatch" href="#UTM.dispatcher.DispatchVertiport.dispatch">dispatch</a></code></li>
<li><code><a title="UTM.dispatcher.DispatchVertiport.generator" href="#UTM.dispatcher.DispatchVertiport.generator">generator</a></code></li>
<li><code><a title="UTM.dispatcher.DispatchVertiport.name" href="#UTM.dispatcher.DispatchVertiport.name">name</a></code></li>
<li><code><a title="UTM.dispatcher.DispatchVertiport.priority" href="#UTM.dispatcher.DispatchVertiport.priority">priority</a></code></li>
<li><code><a title="UTM.dispatcher.DispatchVertiport.render" href="#UTM.dispatcher.DispatchVertiport.render">render</a></code></li>
<li><code><a title="UTM.dispatcher.DispatchVertiport.update" href="#UTM.dispatcher.DispatchVertiport.update">update</a></code></li>
<li><code><a title="UTM.dispatcher.DispatchVertiport.x" href="#UTM.dispatcher.DispatchVertiport.x">x</a></code></li>
<li><code><a title="UTM.dispatcher.DispatchVertiport.y" href="#UTM.dispatcher.DispatchVertiport.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UTM.dispatcher.ReceiveVertiport" href="#UTM.dispatcher.ReceiveVertiport">ReceiveVertiport</a></code></h4>
<ul class="">
<li><code><a title="UTM.dispatcher.ReceiveVertiport.has" href="#UTM.dispatcher.ReceiveVertiport.has">has</a></code></li>
<li><code><a title="UTM.dispatcher.ReceiveVertiport.receive" href="#UTM.dispatcher.ReceiveVertiport.receive">receive</a></code></li>
<li><code><a title="UTM.dispatcher.ReceiveVertiport.ref_count" href="#UTM.dispatcher.ReceiveVertiport.ref_count">ref_count</a></code></li>
<li><code><a title="UTM.dispatcher.ReceiveVertiport.x" href="#UTM.dispatcher.ReceiveVertiport.x">x</a></code></li>
<li><code><a title="UTM.dispatcher.ReceiveVertiport.y" href="#UTM.dispatcher.ReceiveVertiport.y">y</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>