<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>UTM.program API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>UTM.program</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from agents import DroneAgent
from comms import Packet, PacketHeader
from constants import Action2D, DroneSimContext
from drone import DroneStateContext

class CommunicationCapableAgent(DroneAgent):
    &#34;&#34;&#34;
    A simple agent to show how Drone communication will work using the dispatch/ fetch (push/ pull) mechanism.
    Fetching is done outside the agent, assumed to be an abstraction of the drone&#39;s communication drivers.
    env_context has a comms_buffer that will contain all Packet instances relevant to this drone.

    At the moment, if a packet has a drone_id different from the Drone the Agent is working on, it is relevant 
    to the current Drone. However, in later versions of the simulation, there should be a feature to 
    modify which packet the driver can pick up and allow the drone to fetch for the agent. #TODO
    &#34;&#34;&#34;
    def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
        &#34;&#34;&#34;
        Demonstration of fact that the env_context.comms_buffer contains a list of packets
        &#34;&#34;&#34;
        print([packet.header.source_id for packet in env_context.comms_buffer])

        &#34;&#34;&#34;
        Demonstration of how to dispatch packets. These will be available for the next iteration.
        PacketHeader is information that is uniform across all packets, sent by not just this drone but all drones.
        For the sake of real world mapping, rather than extend Packet Header, modify the original class 
            -&gt; This will be analogous to a &#34;software update&#34; on all drones allowing them to read the same type of packeting scheme.
        
        Packet Communication Protocol should allow for a bootstrapping of versions, so that a drone with an 
        older version driver can understand some content of the packet sent by a newer version
        Check with Dr Namuduri if this is a required implementation within scope or more in the scope of network protocol #TODO
        &#34;&#34;&#34;
        env_context.dispatch (
            Packet (
                PacketHeader (
                    drone_context.id
                ),
                [
                    f&#34;Pos: {drone_context.x}, {drone_context.y}&#34;,
                    {&#34;Did you know that:&#34;: &#34;this data can be anything that implements __str__ for the simulation&#39;s sake&#34;}
                ]
            )
        )
        &#34;&#34;&#34;
        Continue moving along the same direction
        &#34;&#34;&#34;
        return drone_context.dir
#TODO: maybe don&#39;t call this an agent
class IntersectionRightAgent(DroneAgent):
    &#34;&#34;&#34;
    A simple agent that is slightly more advanced than the inbuilt ForwardDroneAgent. 
    This one will detect when we are in an intersection and automatically move right.
    Please use maps/intersection-right.map with this agent to prevent crashes due to drones not 
    reaching the goal. 

    When we enter the intersection, we will need to just turn right.
    &#34;&#34;&#34;
    def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
        &#34;&#34;&#34;
        Simple method just checks if our drone is in any intersection.
        An alternative could be to just use:
        env_context.get_containing_intersection(drone_context.x, drone_context.y) is not None
        since DroneSimContext.get_containing_intersection will only return None when it is not in an intersection
        &#34;&#34;&#34;
        isInIntersection = any([
            intersection.has(drone_context.x, drone_context.y)
            for intersection in env_context.intersections
        ])

        &#34;&#34;&#34;
        If we are in an intersection, we lookup which Direction is the &#34;RIGHT&#34; direction of the one
        we are currently on. 
        &#34;&#34;&#34;
        if isInIntersection:
            return Action2D.RIGHT[drone_context.dir]

        &#34;&#34;&#34;
        If we are not in an intersection, we will continue moving along the same direction.
        &#34;&#34;&#34;
        return drone_context.dir

class IntersectionLeftAgent(DroneAgent):
    &#34;&#34;&#34;
    A complex agent that is slightly more advanced than the IntersectionRightAgent. 
    This one will detect when we are in an intersection and automatically move left.
    Please use maps/intersection-left.map with this agent to prevent crashes due to drones not 
    reaching the goal. 

    In the map, to turn left at the intersection, our drone needs to make sure that it 
    comes out on the correct channel. 
    If we are going in from the &#34;Bottom&#34; &#34;East&#34; Channel, the drone must come out through the &#34;Right&#34; &#34;North&#34; Channel.

             | X | ^ |
    Drone -&gt; | &gt; | ^ |

    This is because immediately turning left into an intersection will result in:

             | ^ | X |
    Drone -&gt; | ^ | X |

    however, we now see that the drone is moving North along a South Channel. This will be illegal in the simulation.

    This means that it must make a long turn at the intersection, which needs to be done in 3 iterations:

    To achieve this functionality, we will be using the memory the simulation provides each Drone.


    We can do this by mimicing a state machine to keep track of where we are in the intersection.
    I have simplified the intesection to use a list keeping track of whether we were in an 
    intersection in the last 3 simulation states.

    If the last 2 simulation states were in an intersection, we turn left. Otherwise we move forward.
    This forces a long turn.

    &#34;&#34;&#34;
    def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
        &#34;&#34;&#34;
        This line just checks if the drone is in an intersection.
        DroneSimContext.get_containing_intersection will only return None when the drone is not in an intersection
        &#34;&#34;&#34;
        isInIntersection = env_context.get_containing_intersection(drone_context.x, drone_context.y) is not None
        &#34;&#34;&#34;
        This if statement is true when our drone has just started out. 
        We need to make sure that all memory is initialized.
        Since we have only one variable, we can have a simple guard statement.

        If we plan on having multiple variables, we can have a &#34;flag&#34; in memory, and if that flag is not set
        then we can initialize all the variables.

        The goal is to eventually not require this guard variable. I am debating for now allowing
        variables that do not exist to return None. #TODO
        &#34;&#34;&#34;
        if not &#34;intersectionHistory&#34; in drone_context.mem:
            &#34;&#34;&#34;
            Since our drone has just started, we initialize the last 3 states to be False, False, False meaning
            we were not in an intersection 3 iterations ago.
            &#34;&#34;&#34;
            drone_context.mem.intersectionHistory = [False, False, False]

        &#34;&#34;&#34;
        This line adds the current cycle&#39;s interesection state into the history list we have,
        then it truncates the list to only keep the latest 3 intersections states.
        &#34;&#34;&#34;
        drone_context.mem.intersectionHistory = ([isInIntersection] + drone_context.mem.intersectionHistory)[:3]

        &#34;&#34;&#34;
        If the last 2 intersection states were True and the 3rd (or latest stored history) state was false,
        we have to turn left!
        &#34;&#34;&#34;
        if all(drone_context.mem.intersectionHistory[:-1]) and not drone_context.mem.intersectionHistory[-1]:
            return Action2D.LEFT[drone_context.dir]

        &#34;&#34;&#34;
        In all other cases, we just need to go forward in the direction we were going.
        &#34;&#34;&#34;
        return drone_context.dir

class DFSAgent(DroneAgent):
    &#34;&#34;&#34;
    TODO: basic DFS implementation to show how to check legality of steps and perform known algos 
    TODO: demonstrate that storing data at the agent level is a mem leak -&gt; will never get cleared.
    &#34;&#34;&#34;
    def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
        raise Exception(&#34;Unimplemented agent.&#34;)

class BFSAgent(DroneAgent):
    &#34;&#34;&#34;
    TODO: ask ananay for description, since it has not been put on the github rn.
    &#34;&#34;&#34;
    def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
        raise Exception(&#34;Unimplemented agent.&#34;)

class AStarAgent(DroneAgent):
    &#34;&#34;&#34;
    TODO: ask ananay for description, since it has not been put on the github rn.
    &#34;&#34;&#34;
    def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
        raise Exception(&#34;Unimplemented agent.&#34;)

class DjikstrasAgent(DroneAgent):
    &#34;&#34;&#34;
    TODO: ask ananay for description, since it has not been put on the github rn.
    &#34;&#34;&#34;
    def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
        raise Exception(&#34;Unimplemented agent.&#34;)

EXPORT = {
    &#34;simulation-settings&#34;: {
        &#34;global-agent&#34;: IntersectionLeftAgent
    },
    &#34;main&#34;: {
        &#34;map-file&#34;: &#34;maps/intersection-left.map&#34;,
        &#34;strict-verify&#34;: &#34;simple&#34;
    }
}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="UTM.program.AStarAgent"><code class="flex name class">
<span>class <span class="ident">AStarAgent</span></span>
</code></dt>
<dd>
<div class="desc"><p>TODO: ask ananay for description, since it has not been put on the github rn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AStarAgent(DroneAgent):
    &#34;&#34;&#34;
    TODO: ask ananay for description, since it has not been put on the github rn.
    &#34;&#34;&#34;
    def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
        raise Exception(&#34;Unimplemented agent.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>agents.DroneAgent</li>
<li>agents.Agent</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="UTM.program.AStarAgent.getAction"><code class="name flex">
<span>def <span class="ident">getAction</span></span>(<span>self, drone_context: drone.DroneStateContext, env_context: constants.DroneSimContext)</span>
</code></dt>
<dd>
<div class="desc"><p>Taking in a state, the agent should return the action to be taken.</p>
<p>Agent: entity in a program or environment capable of generating action.
An agent uses perception of the environment to make decisions about actions to take.
The perception capability is usually called a sensor.
The actions can depend on the most recent perception or on the entire history (percept sequence).</p>
<p><a href="https://www.cs.iusb.edu/~danav/teach/c463/3_agents.html">https://www.cs.iusb.edu/~danav/teach/c463/3_agents.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
    raise Exception(&#34;Unimplemented agent.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="UTM.program.BFSAgent"><code class="flex name class">
<span>class <span class="ident">BFSAgent</span></span>
</code></dt>
<dd>
<div class="desc"><p>TODO: ask ananay for description, since it has not been put on the github rn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BFSAgent(DroneAgent):
    &#34;&#34;&#34;
    TODO: ask ananay for description, since it has not been put on the github rn.
    &#34;&#34;&#34;
    def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
        raise Exception(&#34;Unimplemented agent.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>agents.DroneAgent</li>
<li>agents.Agent</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="UTM.program.BFSAgent.getAction"><code class="name flex">
<span>def <span class="ident">getAction</span></span>(<span>self, drone_context: drone.DroneStateContext, env_context: constants.DroneSimContext)</span>
</code></dt>
<dd>
<div class="desc"><p>Taking in a state, the agent should return the action to be taken.</p>
<p>Agent: entity in a program or environment capable of generating action.
An agent uses perception of the environment to make decisions about actions to take.
The perception capability is usually called a sensor.
The actions can depend on the most recent perception or on the entire history (percept sequence).</p>
<p><a href="https://www.cs.iusb.edu/~danav/teach/c463/3_agents.html">https://www.cs.iusb.edu/~danav/teach/c463/3_agents.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
    raise Exception(&#34;Unimplemented agent.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="UTM.program.CommunicationCapableAgent"><code class="flex name class">
<span>class <span class="ident">CommunicationCapableAgent</span></span>
</code></dt>
<dd>
<div class="desc"><p>A simple agent to show how Drone communication will work using the dispatch/ fetch (push/ pull) mechanism.
Fetching is done outside the agent, assumed to be an abstraction of the drone's communication drivers.
env_context has a comms_buffer that will contain all Packet instances relevant to this drone.</p>
<p>At the moment, if a packet has a drone_id different from the Drone the Agent is working on, it is relevant
to the current Drone. However, in later versions of the simulation, there should be a feature to
modify which packet the driver can pick up and allow the drone to fetch for the agent. #TODO</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommunicationCapableAgent(DroneAgent):
    &#34;&#34;&#34;
    A simple agent to show how Drone communication will work using the dispatch/ fetch (push/ pull) mechanism.
    Fetching is done outside the agent, assumed to be an abstraction of the drone&#39;s communication drivers.
    env_context has a comms_buffer that will contain all Packet instances relevant to this drone.

    At the moment, if a packet has a drone_id different from the Drone the Agent is working on, it is relevant 
    to the current Drone. However, in later versions of the simulation, there should be a feature to 
    modify which packet the driver can pick up and allow the drone to fetch for the agent. #TODO
    &#34;&#34;&#34;
    def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
        &#34;&#34;&#34;
        Demonstration of fact that the env_context.comms_buffer contains a list of packets
        &#34;&#34;&#34;
        print([packet.header.source_id for packet in env_context.comms_buffer])

        &#34;&#34;&#34;
        Demonstration of how to dispatch packets. These will be available for the next iteration.
        PacketHeader is information that is uniform across all packets, sent by not just this drone but all drones.
        For the sake of real world mapping, rather than extend Packet Header, modify the original class 
            -&gt; This will be analogous to a &#34;software update&#34; on all drones allowing them to read the same type of packeting scheme.
        
        Packet Communication Protocol should allow for a bootstrapping of versions, so that a drone with an 
        older version driver can understand some content of the packet sent by a newer version
        Check with Dr Namuduri if this is a required implementation within scope or more in the scope of network protocol #TODO
        &#34;&#34;&#34;
        env_context.dispatch (
            Packet (
                PacketHeader (
                    drone_context.id
                ),
                [
                    f&#34;Pos: {drone_context.x}, {drone_context.y}&#34;,
                    {&#34;Did you know that:&#34;: &#34;this data can be anything that implements __str__ for the simulation&#39;s sake&#34;}
                ]
            )
        )
        &#34;&#34;&#34;
        Continue moving along the same direction
        &#34;&#34;&#34;
        return drone_context.dir</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>agents.DroneAgent</li>
<li>agents.Agent</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="UTM.program.CommunicationCapableAgent.getAction"><code class="name flex">
<span>def <span class="ident">getAction</span></span>(<span>self, drone_context: drone.DroneStateContext, env_context: constants.DroneSimContext)</span>
</code></dt>
<dd>
<div class="desc"><p>Demonstration of fact that the env_context.comms_buffer contains a list of packets</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
    &#34;&#34;&#34;
    Demonstration of fact that the env_context.comms_buffer contains a list of packets
    &#34;&#34;&#34;
    print([packet.header.source_id for packet in env_context.comms_buffer])

    &#34;&#34;&#34;
    Demonstration of how to dispatch packets. These will be available for the next iteration.
    PacketHeader is information that is uniform across all packets, sent by not just this drone but all drones.
    For the sake of real world mapping, rather than extend Packet Header, modify the original class 
        -&gt; This will be analogous to a &#34;software update&#34; on all drones allowing them to read the same type of packeting scheme.
    
    Packet Communication Protocol should allow for a bootstrapping of versions, so that a drone with an 
    older version driver can understand some content of the packet sent by a newer version
    Check with Dr Namuduri if this is a required implementation within scope or more in the scope of network protocol #TODO
    &#34;&#34;&#34;
    env_context.dispatch (
        Packet (
            PacketHeader (
                drone_context.id
            ),
            [
                f&#34;Pos: {drone_context.x}, {drone_context.y}&#34;,
                {&#34;Did you know that:&#34;: &#34;this data can be anything that implements __str__ for the simulation&#39;s sake&#34;}
            ]
        )
    )
    &#34;&#34;&#34;
    Continue moving along the same direction
    &#34;&#34;&#34;
    return drone_context.dir</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="UTM.program.DFSAgent"><code class="flex name class">
<span>class <span class="ident">DFSAgent</span></span>
</code></dt>
<dd>
<div class="desc"><p>TODO: basic DFS implementation to show how to check legality of steps and perform known algos
TODO: demonstrate that storing data at the agent level is a mem leak -&gt; will never get cleared.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DFSAgent(DroneAgent):
    &#34;&#34;&#34;
    TODO: basic DFS implementation to show how to check legality of steps and perform known algos 
    TODO: demonstrate that storing data at the agent level is a mem leak -&gt; will never get cleared.
    &#34;&#34;&#34;
    def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
        raise Exception(&#34;Unimplemented agent.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>agents.DroneAgent</li>
<li>agents.Agent</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="UTM.program.DFSAgent.getAction"><code class="name flex">
<span>def <span class="ident">getAction</span></span>(<span>self, drone_context: drone.DroneStateContext, env_context: constants.DroneSimContext)</span>
</code></dt>
<dd>
<div class="desc"><p>Taking in a state, the agent should return the action to be taken.</p>
<p>Agent: entity in a program or environment capable of generating action.
An agent uses perception of the environment to make decisions about actions to take.
The perception capability is usually called a sensor.
The actions can depend on the most recent perception or on the entire history (percept sequence).</p>
<p><a href="https://www.cs.iusb.edu/~danav/teach/c463/3_agents.html">https://www.cs.iusb.edu/~danav/teach/c463/3_agents.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
    raise Exception(&#34;Unimplemented agent.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="UTM.program.DjikstrasAgent"><code class="flex name class">
<span>class <span class="ident">DjikstrasAgent</span></span>
</code></dt>
<dd>
<div class="desc"><p>TODO: ask ananay for description, since it has not been put on the github rn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DjikstrasAgent(DroneAgent):
    &#34;&#34;&#34;
    TODO: ask ananay for description, since it has not been put on the github rn.
    &#34;&#34;&#34;
    def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
        raise Exception(&#34;Unimplemented agent.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>agents.DroneAgent</li>
<li>agents.Agent</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="UTM.program.DjikstrasAgent.getAction"><code class="name flex">
<span>def <span class="ident">getAction</span></span>(<span>self, drone_context: drone.DroneStateContext, env_context: constants.DroneSimContext)</span>
</code></dt>
<dd>
<div class="desc"><p>Taking in a state, the agent should return the action to be taken.</p>
<p>Agent: entity in a program or environment capable of generating action.
An agent uses perception of the environment to make decisions about actions to take.
The perception capability is usually called a sensor.
The actions can depend on the most recent perception or on the entire history (percept sequence).</p>
<p><a href="https://www.cs.iusb.edu/~danav/teach/c463/3_agents.html">https://www.cs.iusb.edu/~danav/teach/c463/3_agents.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
    raise Exception(&#34;Unimplemented agent.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="UTM.program.IntersectionLeftAgent"><code class="flex name class">
<span>class <span class="ident">IntersectionLeftAgent</span></span>
</code></dt>
<dd>
<div class="desc"><p>A complex agent that is slightly more advanced than the IntersectionRightAgent.
This one will detect when we are in an intersection and automatically move left.
Please use maps/intersection-left.map with this agent to prevent crashes due to drones not
reaching the goal. </p>
<p>In the map, to turn left at the intersection, our drone needs to make sure that it
comes out on the correct channel.
If we are going in from the "Bottom" "East" Channel, the drone must come out through the "Right" "North" Channel.</p>
<pre><code>     | X | ^ |
</code></pre>
<p>Drone -&gt; | &gt; | ^ |</p>
<p>This is because immediately turning left into an intersection will result in:</p>
<pre><code>     | ^ | X |
</code></pre>
<p>Drone -&gt; | ^ | X |</p>
<p>however, we now see that the drone is moving North along a South Channel. This will be illegal in the simulation.</p>
<p>This means that it must make a long turn at the intersection, which needs to be done in 3 iterations:</p>
<p>To achieve this functionality, we will be using the memory the simulation provides each Drone.</p>
<p>We can do this by mimicing a state machine to keep track of where we are in the intersection.
I have simplified the intesection to use a list keeping track of whether we were in an
intersection in the last 3 simulation states.</p>
<p>If the last 2 simulation states were in an intersection, we turn left. Otherwise we move forward.
This forces a long turn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntersectionLeftAgent(DroneAgent):
    &#34;&#34;&#34;
    A complex agent that is slightly more advanced than the IntersectionRightAgent. 
    This one will detect when we are in an intersection and automatically move left.
    Please use maps/intersection-left.map with this agent to prevent crashes due to drones not 
    reaching the goal. 

    In the map, to turn left at the intersection, our drone needs to make sure that it 
    comes out on the correct channel. 
    If we are going in from the &#34;Bottom&#34; &#34;East&#34; Channel, the drone must come out through the &#34;Right&#34; &#34;North&#34; Channel.

             | X | ^ |
    Drone -&gt; | &gt; | ^ |

    This is because immediately turning left into an intersection will result in:

             | ^ | X |
    Drone -&gt; | ^ | X |

    however, we now see that the drone is moving North along a South Channel. This will be illegal in the simulation.

    This means that it must make a long turn at the intersection, which needs to be done in 3 iterations:

    To achieve this functionality, we will be using the memory the simulation provides each Drone.


    We can do this by mimicing a state machine to keep track of where we are in the intersection.
    I have simplified the intesection to use a list keeping track of whether we were in an 
    intersection in the last 3 simulation states.

    If the last 2 simulation states were in an intersection, we turn left. Otherwise we move forward.
    This forces a long turn.

    &#34;&#34;&#34;
    def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
        &#34;&#34;&#34;
        This line just checks if the drone is in an intersection.
        DroneSimContext.get_containing_intersection will only return None when the drone is not in an intersection
        &#34;&#34;&#34;
        isInIntersection = env_context.get_containing_intersection(drone_context.x, drone_context.y) is not None
        &#34;&#34;&#34;
        This if statement is true when our drone has just started out. 
        We need to make sure that all memory is initialized.
        Since we have only one variable, we can have a simple guard statement.

        If we plan on having multiple variables, we can have a &#34;flag&#34; in memory, and if that flag is not set
        then we can initialize all the variables.

        The goal is to eventually not require this guard variable. I am debating for now allowing
        variables that do not exist to return None. #TODO
        &#34;&#34;&#34;
        if not &#34;intersectionHistory&#34; in drone_context.mem:
            &#34;&#34;&#34;
            Since our drone has just started, we initialize the last 3 states to be False, False, False meaning
            we were not in an intersection 3 iterations ago.
            &#34;&#34;&#34;
            drone_context.mem.intersectionHistory = [False, False, False]

        &#34;&#34;&#34;
        This line adds the current cycle&#39;s interesection state into the history list we have,
        then it truncates the list to only keep the latest 3 intersections states.
        &#34;&#34;&#34;
        drone_context.mem.intersectionHistory = ([isInIntersection] + drone_context.mem.intersectionHistory)[:3]

        &#34;&#34;&#34;
        If the last 2 intersection states were True and the 3rd (or latest stored history) state was false,
        we have to turn left!
        &#34;&#34;&#34;
        if all(drone_context.mem.intersectionHistory[:-1]) and not drone_context.mem.intersectionHistory[-1]:
            return Action2D.LEFT[drone_context.dir]

        &#34;&#34;&#34;
        In all other cases, we just need to go forward in the direction we were going.
        &#34;&#34;&#34;
        return drone_context.dir</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>agents.DroneAgent</li>
<li>agents.Agent</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="UTM.program.IntersectionLeftAgent.getAction"><code class="name flex">
<span>def <span class="ident">getAction</span></span>(<span>self, drone_context: drone.DroneStateContext, env_context: constants.DroneSimContext)</span>
</code></dt>
<dd>
<div class="desc"><p>This line just checks if the drone is in an intersection.
DroneSimContext.get_containing_intersection will only return None when the drone is not in an intersection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
    &#34;&#34;&#34;
    This line just checks if the drone is in an intersection.
    DroneSimContext.get_containing_intersection will only return None when the drone is not in an intersection
    &#34;&#34;&#34;
    isInIntersection = env_context.get_containing_intersection(drone_context.x, drone_context.y) is not None
    &#34;&#34;&#34;
    This if statement is true when our drone has just started out. 
    We need to make sure that all memory is initialized.
    Since we have only one variable, we can have a simple guard statement.

    If we plan on having multiple variables, we can have a &#34;flag&#34; in memory, and if that flag is not set
    then we can initialize all the variables.

    The goal is to eventually not require this guard variable. I am debating for now allowing
    variables that do not exist to return None. #TODO
    &#34;&#34;&#34;
    if not &#34;intersectionHistory&#34; in drone_context.mem:
        &#34;&#34;&#34;
        Since our drone has just started, we initialize the last 3 states to be False, False, False meaning
        we were not in an intersection 3 iterations ago.
        &#34;&#34;&#34;
        drone_context.mem.intersectionHistory = [False, False, False]

    &#34;&#34;&#34;
    This line adds the current cycle&#39;s interesection state into the history list we have,
    then it truncates the list to only keep the latest 3 intersections states.
    &#34;&#34;&#34;
    drone_context.mem.intersectionHistory = ([isInIntersection] + drone_context.mem.intersectionHistory)[:3]

    &#34;&#34;&#34;
    If the last 2 intersection states were True and the 3rd (or latest stored history) state was false,
    we have to turn left!
    &#34;&#34;&#34;
    if all(drone_context.mem.intersectionHistory[:-1]) and not drone_context.mem.intersectionHistory[-1]:
        return Action2D.LEFT[drone_context.dir]

    &#34;&#34;&#34;
    In all other cases, we just need to go forward in the direction we were going.
    &#34;&#34;&#34;
    return drone_context.dir</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="UTM.program.IntersectionRightAgent"><code class="flex name class">
<span>class <span class="ident">IntersectionRightAgent</span></span>
</code></dt>
<dd>
<div class="desc"><p>A simple agent that is slightly more advanced than the inbuilt ForwardDroneAgent.
This one will detect when we are in an intersection and automatically move right.
Please use maps/intersection-right.map with this agent to prevent crashes due to drones not
reaching the goal. </p>
<p>When we enter the intersection, we will need to just turn right.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntersectionRightAgent(DroneAgent):
    &#34;&#34;&#34;
    A simple agent that is slightly more advanced than the inbuilt ForwardDroneAgent. 
    This one will detect when we are in an intersection and automatically move right.
    Please use maps/intersection-right.map with this agent to prevent crashes due to drones not 
    reaching the goal. 

    When we enter the intersection, we will need to just turn right.
    &#34;&#34;&#34;
    def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
        &#34;&#34;&#34;
        Simple method just checks if our drone is in any intersection.
        An alternative could be to just use:
        env_context.get_containing_intersection(drone_context.x, drone_context.y) is not None
        since DroneSimContext.get_containing_intersection will only return None when it is not in an intersection
        &#34;&#34;&#34;
        isInIntersection = any([
            intersection.has(drone_context.x, drone_context.y)
            for intersection in env_context.intersections
        ])

        &#34;&#34;&#34;
        If we are in an intersection, we lookup which Direction is the &#34;RIGHT&#34; direction of the one
        we are currently on. 
        &#34;&#34;&#34;
        if isInIntersection:
            return Action2D.RIGHT[drone_context.dir]

        &#34;&#34;&#34;
        If we are not in an intersection, we will continue moving along the same direction.
        &#34;&#34;&#34;
        return drone_context.dir</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>agents.DroneAgent</li>
<li>agents.Agent</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="UTM.program.IntersectionRightAgent.getAction"><code class="name flex">
<span>def <span class="ident">getAction</span></span>(<span>self, drone_context: drone.DroneStateContext, env_context: constants.DroneSimContext)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple method just checks if our drone is in any intersection.
An alternative could be to just use:
env_context.get_containing_intersection(drone_context.x, drone_context.y) is not None
since DroneSimContext.get_containing_intersection will only return None when it is not in an intersection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAction(self, drone_context: DroneStateContext, env_context: DroneSimContext):
    &#34;&#34;&#34;
    Simple method just checks if our drone is in any intersection.
    An alternative could be to just use:
    env_context.get_containing_intersection(drone_context.x, drone_context.y) is not None
    since DroneSimContext.get_containing_intersection will only return None when it is not in an intersection
    &#34;&#34;&#34;
    isInIntersection = any([
        intersection.has(drone_context.x, drone_context.y)
        for intersection in env_context.intersections
    ])

    &#34;&#34;&#34;
    If we are in an intersection, we lookup which Direction is the &#34;RIGHT&#34; direction of the one
    we are currently on. 
    &#34;&#34;&#34;
    if isInIntersection:
        return Action2D.RIGHT[drone_context.dir]

    &#34;&#34;&#34;
    If we are not in an intersection, we will continue moving along the same direction.
    &#34;&#34;&#34;
    return drone_context.dir</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="UTM" href="index.html">UTM</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="UTM.program.AStarAgent" href="#UTM.program.AStarAgent">AStarAgent</a></code></h4>
<ul class="">
<li><code><a title="UTM.program.AStarAgent.getAction" href="#UTM.program.AStarAgent.getAction">getAction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UTM.program.BFSAgent" href="#UTM.program.BFSAgent">BFSAgent</a></code></h4>
<ul class="">
<li><code><a title="UTM.program.BFSAgent.getAction" href="#UTM.program.BFSAgent.getAction">getAction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UTM.program.CommunicationCapableAgent" href="#UTM.program.CommunicationCapableAgent">CommunicationCapableAgent</a></code></h4>
<ul class="">
<li><code><a title="UTM.program.CommunicationCapableAgent.getAction" href="#UTM.program.CommunicationCapableAgent.getAction">getAction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UTM.program.DFSAgent" href="#UTM.program.DFSAgent">DFSAgent</a></code></h4>
<ul class="">
<li><code><a title="UTM.program.DFSAgent.getAction" href="#UTM.program.DFSAgent.getAction">getAction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UTM.program.DjikstrasAgent" href="#UTM.program.DjikstrasAgent">DjikstrasAgent</a></code></h4>
<ul class="">
<li><code><a title="UTM.program.DjikstrasAgent.getAction" href="#UTM.program.DjikstrasAgent.getAction">getAction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UTM.program.IntersectionLeftAgent" href="#UTM.program.IntersectionLeftAgent">IntersectionLeftAgent</a></code></h4>
<ul class="">
<li><code><a title="UTM.program.IntersectionLeftAgent.getAction" href="#UTM.program.IntersectionLeftAgent.getAction">getAction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UTM.program.IntersectionRightAgent" href="#UTM.program.IntersectionRightAgent">IntersectionRightAgent</a></code></h4>
<ul class="">
<li><code><a title="UTM.program.IntersectionRightAgent.getAction" href="#UTM.program.IntersectionRightAgent.getAction">getAction</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>